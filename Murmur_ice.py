# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.7
#
# <auto-generated>
#
# Generated from file `Murmur.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy
import Ice.SliceChecksumDict_ice

# Included module Ice
_M_Ice = Ice.openModule('Ice')

# Start of module Murmur
_M_Murmur = Ice.openModule('Murmur')
__name__ = 'Murmur'

if '_t_NetAddress' not in _M_Murmur.__dict__:
    _M_Murmur._t_NetAddress = IcePy.defineSequence('::Murmur::NetAddress', ('python:seq:tuple',), IcePy._t_byte)

if 'User' not in _M_Murmur.__dict__:
    _M_Murmur.User = Ice.createTempClass()
    class User(object):
        """
        A connected user.
        Members:
        session -- Session ID. This identifies the connection to the server.
        userid -- User ID. -1 if the user is anonymous.
        mute -- Is user muted by the server?
        deaf -- Is user deafened by the server? If true, this implies mute.
        suppress -- Is the user suppressed by the server? This means the user is not muted, but does not have speech privileges in the current channel.
        prioritySpeaker -- Is the user a priority speaker?
        selfMute -- Is the user self-muted?
        selfDeaf -- Is the user self-deafened? If true, this implies mute.
        recording -- Is the User recording? (This flag is read-only and cannot be changed using setState().)
        channel -- Channel ID the user is in. Matches Channel.id.
        name -- The name of the user.
        onlinesecs -- Seconds user has been online.
        bytespersec -- Average transmission rate in bytes per second over the last few seconds.
        version -- Client version. Major version in upper 16 bits, followed by 8 bits of minor version and 8 bits of patchlevel. Version 1.2.3 = 0x010203.
        release -- Client release. For official releases, this equals the version. For snapshots and git compiles, this will be something else.
        os -- Client OS.
        osversion -- Client OS Version.
        identity -- Plugin Identity. This will be the user's unique ID inside the current game.
        context -- Base64-encoded Plugin context. This is a binary blob identifying the game and team the user is on.
        The used Base64 alphabet is the one specified in RFC 2045.
        Before Mumble 1.3.0, this string was not Base64-encoded. This could cause problems for some Ice
        implementations, such as the .NET implementation.
        If you need the exact string that is used by Mumble, you can get it by Base64-decoding this string.
        If you simply need to detect whether two users are in the same game world, string comparisons will
        continue to work as before.
        comment -- User comment. Shown as tooltip for this user.
        address -- Client address.
        tcponly -- TCP only. True until UDP connectivity is established.
        idlesecs -- Idle time. This is how many seconds it is since the user last spoke. Other activity is not counted.
        udpPing -- UDP Ping Average. This is the average ping for the user via UDP over the duration of the connection.
        tcpPing -- TCP Ping Average. This is the average ping for the user via TCP over the duration of the connection.
        """
        def __init__(self, session=0, userid=0, mute=False, deaf=False, suppress=False, prioritySpeaker=False, selfMute=False, selfDeaf=False, recording=False, channel=0, name='', onlinesecs=0, bytespersec=0, version=0, release='', os='', osversion='', identity='', context='', comment='', address=None, tcponly=False, idlesecs=0, udpPing=0.0, tcpPing=0.0):
            self.session = session
            self.userid = userid
            self.mute = mute
            self.deaf = deaf
            self.suppress = suppress
            self.prioritySpeaker = prioritySpeaker
            self.selfMute = selfMute
            self.selfDeaf = selfDeaf
            self.recording = recording
            self.channel = channel
            self.name = name
            self.onlinesecs = onlinesecs
            self.bytespersec = bytespersec
            self.version = version
            self.release = release
            self.os = os
            self.osversion = osversion
            self.identity = identity
            self.context = context
            self.comment = comment
            self.address = address
            self.tcponly = tcponly
            self.idlesecs = idlesecs
            self.udpPing = udpPing
            self.tcpPing = tcpPing

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_Murmur.User):
                return NotImplemented
            else:
                if self.session != other.session:
                    return False
                if self.userid != other.userid:
                    return False
                if self.mute != other.mute:
                    return False
                if self.deaf != other.deaf:
                    return False
                if self.suppress != other.suppress:
                    return False
                if self.prioritySpeaker != other.prioritySpeaker:
                    return False
                if self.selfMute != other.selfMute:
                    return False
                if self.selfDeaf != other.selfDeaf:
                    return False
                if self.recording != other.recording:
                    return False
                if self.channel != other.channel:
                    return False
                if self.name != other.name:
                    return False
                if self.onlinesecs != other.onlinesecs:
                    return False
                if self.bytespersec != other.bytespersec:
                    return False
                if self.version != other.version:
                    return False
                if self.release != other.release:
                    return False
                if self.os != other.os:
                    return False
                if self.osversion != other.osversion:
                    return False
                if self.identity != other.identity:
                    return False
                if self.context != other.context:
                    return False
                if self.comment != other.comment:
                    return False
                if self.address != other.address:
                    return False
                if self.tcponly != other.tcponly:
                    return False
                if self.idlesecs != other.idlesecs:
                    return False
                if self.udpPing != other.udpPing:
                    return False
                if self.tcpPing != other.tcpPing:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_User)

        __repr__ = __str__

    _M_Murmur._t_User = IcePy.defineStruct('::Murmur::User', User, (), (
        ('session', (), IcePy._t_int),
        ('userid', (), IcePy._t_int),
        ('mute', (), IcePy._t_bool),
        ('deaf', (), IcePy._t_bool),
        ('suppress', (), IcePy._t_bool),
        ('prioritySpeaker', (), IcePy._t_bool),
        ('selfMute', (), IcePy._t_bool),
        ('selfDeaf', (), IcePy._t_bool),
        ('recording', (), IcePy._t_bool),
        ('channel', (), IcePy._t_int),
        ('name', (), IcePy._t_string),
        ('onlinesecs', (), IcePy._t_int),
        ('bytespersec', (), IcePy._t_int),
        ('version', (), IcePy._t_int),
        ('release', (), IcePy._t_string),
        ('os', (), IcePy._t_string),
        ('osversion', (), IcePy._t_string),
        ('identity', (), IcePy._t_string),
        ('context', (), IcePy._t_string),
        ('comment', (), IcePy._t_string),
        ('address', (), _M_Murmur._t_NetAddress),
        ('tcponly', (), IcePy._t_bool),
        ('idlesecs', (), IcePy._t_int),
        ('udpPing', (), IcePy._t_float),
        ('tcpPing', (), IcePy._t_float)
    ))

    _M_Murmur.User = User
    del User

if '_t_IntList' not in _M_Murmur.__dict__:
    _M_Murmur._t_IntList = IcePy.defineSequence('::Murmur::IntList', (), IcePy._t_int)

if 'TextMessage' not in _M_Murmur.__dict__:
    _M_Murmur.TextMessage = Ice.createTempClass()
    class TextMessage(object):
        """
        A text message between users.
        Members:
        sessions -- Sessions (connected users) who were sent this message.
        channels -- Channels who were sent this message.
        trees -- Trees of channels who were sent this message.
        text -- The contents of the message.
        """
        def __init__(self, sessions=None, channels=None, trees=None, text=''):
            self.sessions = sessions
            self.channels = channels
            self.trees = trees
            self.text = text

        def __hash__(self):
            _h = 0
            if self.sessions:
                for _i0 in self.sessions:
                    _h = 5 * _h + Ice.getHash(_i0)
            if self.channels:
                for _i1 in self.channels:
                    _h = 5 * _h + Ice.getHash(_i1)
            if self.trees:
                for _i2 in self.trees:
                    _h = 5 * _h + Ice.getHash(_i2)
            _h = 5 * _h + Ice.getHash(self.text)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Murmur.TextMessage):
                return NotImplemented
            else:
                if self.sessions is None or other.sessions is None:
                    if self.sessions != other.sessions:
                        return (-1 if self.sessions is None else 1)
                else:
                    if self.sessions < other.sessions:
                        return -1
                    elif self.sessions > other.sessions:
                        return 1
                if self.channels is None or other.channels is None:
                    if self.channels != other.channels:
                        return (-1 if self.channels is None else 1)
                else:
                    if self.channels < other.channels:
                        return -1
                    elif self.channels > other.channels:
                        return 1
                if self.trees is None or other.trees is None:
                    if self.trees != other.trees:
                        return (-1 if self.trees is None else 1)
                else:
                    if self.trees < other.trees:
                        return -1
                    elif self.trees > other.trees:
                        return 1
                if self.text is None or other.text is None:
                    if self.text != other.text:
                        return (-1 if self.text is None else 1)
                else:
                    if self.text < other.text:
                        return -1
                    elif self.text > other.text:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_TextMessage)

        __repr__ = __str__

    _M_Murmur._t_TextMessage = IcePy.defineStruct('::Murmur::TextMessage', TextMessage, (), (
        ('sessions', (), _M_Murmur._t_IntList),
        ('channels', (), _M_Murmur._t_IntList),
        ('trees', (), _M_Murmur._t_IntList),
        ('text', (), IcePy._t_string)
    ))

    _M_Murmur.TextMessage = TextMessage
    del TextMessage

if 'Channel' not in _M_Murmur.__dict__:
    _M_Murmur.Channel = Ice.createTempClass()
    class Channel(object):
        """
        A channel.
        Members:
        id -- Channel ID. This is unique per channel, and the root channel is always id 0.
        name -- Name of the channel. There can not be two channels with the same parent that has the same name.
        parent -- ID of parent channel, or -1 if this is the root channel.
        links -- List of id of linked channels.
        description -- Description of channel. Shown as tooltip for this channel.
        temporary -- Channel is temporary, and will be removed when the last user leaves it.
        position -- Position of the channel which is used in Client for sorting.
        """
        def __init__(self, id=0, name='', parent=0, links=None, description='', temporary=False, position=0):
            self.id = id
            self.name = name
            self.parent = parent
            self.links = links
            self.description = description
            self.temporary = temporary
            self.position = position

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.id)
            _h = 5 * _h + Ice.getHash(self.name)
            _h = 5 * _h + Ice.getHash(self.parent)
            if self.links:
                for _i0 in self.links:
                    _h = 5 * _h + Ice.getHash(_i0)
            _h = 5 * _h + Ice.getHash(self.description)
            _h = 5 * _h + Ice.getHash(self.temporary)
            _h = 5 * _h + Ice.getHash(self.position)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Murmur.Channel):
                return NotImplemented
            else:
                if self.id is None or other.id is None:
                    if self.id != other.id:
                        return (-1 if self.id is None else 1)
                else:
                    if self.id < other.id:
                        return -1
                    elif self.id > other.id:
                        return 1
                if self.name is None or other.name is None:
                    if self.name != other.name:
                        return (-1 if self.name is None else 1)
                else:
                    if self.name < other.name:
                        return -1
                    elif self.name > other.name:
                        return 1
                if self.parent is None or other.parent is None:
                    if self.parent != other.parent:
                        return (-1 if self.parent is None else 1)
                else:
                    if self.parent < other.parent:
                        return -1
                    elif self.parent > other.parent:
                        return 1
                if self.links is None or other.links is None:
                    if self.links != other.links:
                        return (-1 if self.links is None else 1)
                else:
                    if self.links < other.links:
                        return -1
                    elif self.links > other.links:
                        return 1
                if self.description is None or other.description is None:
                    if self.description != other.description:
                        return (-1 if self.description is None else 1)
                else:
                    if self.description < other.description:
                        return -1
                    elif self.description > other.description:
                        return 1
                if self.temporary is None or other.temporary is None:
                    if self.temporary != other.temporary:
                        return (-1 if self.temporary is None else 1)
                else:
                    if self.temporary < other.temporary:
                        return -1
                    elif self.temporary > other.temporary:
                        return 1
                if self.position is None or other.position is None:
                    if self.position != other.position:
                        return (-1 if self.position is None else 1)
                else:
                    if self.position < other.position:
                        return -1
                    elif self.position > other.position:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_Channel)

        __repr__ = __str__

    _M_Murmur._t_Channel = IcePy.defineStruct('::Murmur::Channel', Channel, (), (
        ('id', (), IcePy._t_int),
        ('name', (), IcePy._t_string),
        ('parent', (), IcePy._t_int),
        ('links', (), _M_Murmur._t_IntList),
        ('description', (), IcePy._t_string),
        ('temporary', (), IcePy._t_bool),
        ('position', (), IcePy._t_int)
    ))

    _M_Murmur.Channel = Channel
    del Channel

if 'Group' not in _M_Murmur.__dict__:
    _M_Murmur.Group = Ice.createTempClass()
    class Group(object):
        """
        A group. Groups are defined per channel, and can inherit members from parent channels.
        Members:
        name -- Group name
        inherited -- Is this group inherited from a parent channel? Read-only.
        inherit -- Does this group inherit members from parent channels?
        inheritable -- Can subchannels inherit members from this group?
        add -- List of users to add to the group.
        remove -- List of inherited users to remove from the group.
        members -- Current members of the group, including inherited members. Read-only.
        """
        def __init__(self, name='', inherited=False, inherit=False, inheritable=False, add=None, remove=None, members=None):
            self.name = name
            self.inherited = inherited
            self.inherit = inherit
            self.inheritable = inheritable
            self.add = add
            self.remove = remove
            self.members = members

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.name)
            _h = 5 * _h + Ice.getHash(self.inherited)
            _h = 5 * _h + Ice.getHash(self.inherit)
            _h = 5 * _h + Ice.getHash(self.inheritable)
            if self.add:
                for _i0 in self.add:
                    _h = 5 * _h + Ice.getHash(_i0)
            if self.remove:
                for _i1 in self.remove:
                    _h = 5 * _h + Ice.getHash(_i1)
            if self.members:
                for _i2 in self.members:
                    _h = 5 * _h + Ice.getHash(_i2)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Murmur.Group):
                return NotImplemented
            else:
                if self.name is None or other.name is None:
                    if self.name != other.name:
                        return (-1 if self.name is None else 1)
                else:
                    if self.name < other.name:
                        return -1
                    elif self.name > other.name:
                        return 1
                if self.inherited is None or other.inherited is None:
                    if self.inherited != other.inherited:
                        return (-1 if self.inherited is None else 1)
                else:
                    if self.inherited < other.inherited:
                        return -1
                    elif self.inherited > other.inherited:
                        return 1
                if self.inherit is None or other.inherit is None:
                    if self.inherit != other.inherit:
                        return (-1 if self.inherit is None else 1)
                else:
                    if self.inherit < other.inherit:
                        return -1
                    elif self.inherit > other.inherit:
                        return 1
                if self.inheritable is None or other.inheritable is None:
                    if self.inheritable != other.inheritable:
                        return (-1 if self.inheritable is None else 1)
                else:
                    if self.inheritable < other.inheritable:
                        return -1
                    elif self.inheritable > other.inheritable:
                        return 1
                if self.add is None or other.add is None:
                    if self.add != other.add:
                        return (-1 if self.add is None else 1)
                else:
                    if self.add < other.add:
                        return -1
                    elif self.add > other.add:
                        return 1
                if self.remove is None or other.remove is None:
                    if self.remove != other.remove:
                        return (-1 if self.remove is None else 1)
                else:
                    if self.remove < other.remove:
                        return -1
                    elif self.remove > other.remove:
                        return 1
                if self.members is None or other.members is None:
                    if self.members != other.members:
                        return (-1 if self.members is None else 1)
                else:
                    if self.members < other.members:
                        return -1
                    elif self.members > other.members:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_Group)

        __repr__ = __str__

    _M_Murmur._t_Group = IcePy.defineStruct('::Murmur::Group', Group, (), (
        ('name', (), IcePy._t_string),
        ('inherited', (), IcePy._t_bool),
        ('inherit', (), IcePy._t_bool),
        ('inheritable', (), IcePy._t_bool),
        ('add', (), _M_Murmur._t_IntList),
        ('remove', (), _M_Murmur._t_IntList),
        ('members', (), _M_Murmur._t_IntList)
    ))

    _M_Murmur.Group = Group
    del Group

_M_Murmur.PermissionWrite = 1

_M_Murmur.PermissionTraverse = 2

_M_Murmur.PermissionEnter = 4

_M_Murmur.PermissionSpeak = 8

_M_Murmur.PermissionWhisper = 256

_M_Murmur.PermissionMuteDeafen = 16

_M_Murmur.PermissionMove = 32

_M_Murmur.PermissionMakeChannel = 64

_M_Murmur.PermissionMakeTempChannel = 1024

_M_Murmur.PermissionLinkChannel = 128

_M_Murmur.PermissionTextMessage = 512

_M_Murmur.PermissionKick = 65536

_M_Murmur.PermissionBan = 131072

_M_Murmur.PermissionRegister = 262144

_M_Murmur.PermissionRegisterSelf = 524288

_M_Murmur.ResetUserContent = 1048576

if 'ACL' not in _M_Murmur.__dict__:
    _M_Murmur.ACL = Ice.createTempClass()
    class ACL(object):
        """
        Access Control List for a channel. ACLs are defined per channel, and can be inherited from parent channels.
        Members:
        applyHere -- Does the ACL apply to this channel?
        applySubs -- Does the ACL apply to subchannels?
        inherited -- Is this ACL inherited from a parent channel? Read-only.
        userid -- ID of user this ACL applies to. -1 if using a group name.
        group -- Group this ACL applies to. Blank if using userid.
        allow -- Binary mask of privileges to allow.
        deny -- Binary mask of privileges to deny.
        """
        def __init__(self, applyHere=False, applySubs=False, inherited=False, userid=0, group='', allow=0, deny=0):
            self.applyHere = applyHere
            self.applySubs = applySubs
            self.inherited = inherited
            self.userid = userid
            self.group = group
            self.allow = allow
            self.deny = deny

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.applyHere)
            _h = 5 * _h + Ice.getHash(self.applySubs)
            _h = 5 * _h + Ice.getHash(self.inherited)
            _h = 5 * _h + Ice.getHash(self.userid)
            _h = 5 * _h + Ice.getHash(self.group)
            _h = 5 * _h + Ice.getHash(self.allow)
            _h = 5 * _h + Ice.getHash(self.deny)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Murmur.ACL):
                return NotImplemented
            else:
                if self.applyHere is None or other.applyHere is None:
                    if self.applyHere != other.applyHere:
                        return (-1 if self.applyHere is None else 1)
                else:
                    if self.applyHere < other.applyHere:
                        return -1
                    elif self.applyHere > other.applyHere:
                        return 1
                if self.applySubs is None or other.applySubs is None:
                    if self.applySubs != other.applySubs:
                        return (-1 if self.applySubs is None else 1)
                else:
                    if self.applySubs < other.applySubs:
                        return -1
                    elif self.applySubs > other.applySubs:
                        return 1
                if self.inherited is None or other.inherited is None:
                    if self.inherited != other.inherited:
                        return (-1 if self.inherited is None else 1)
                else:
                    if self.inherited < other.inherited:
                        return -1
                    elif self.inherited > other.inherited:
                        return 1
                if self.userid is None or other.userid is None:
                    if self.userid != other.userid:
                        return (-1 if self.userid is None else 1)
                else:
                    if self.userid < other.userid:
                        return -1
                    elif self.userid > other.userid:
                        return 1
                if self.group is None or other.group is None:
                    if self.group != other.group:
                        return (-1 if self.group is None else 1)
                else:
                    if self.group < other.group:
                        return -1
                    elif self.group > other.group:
                        return 1
                if self.allow is None or other.allow is None:
                    if self.allow != other.allow:
                        return (-1 if self.allow is None else 1)
                else:
                    if self.allow < other.allow:
                        return -1
                    elif self.allow > other.allow:
                        return 1
                if self.deny is None or other.deny is None:
                    if self.deny != other.deny:
                        return (-1 if self.deny is None else 1)
                else:
                    if self.deny < other.deny:
                        return -1
                    elif self.deny > other.deny:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_ACL)

        __repr__ = __str__

    _M_Murmur._t_ACL = IcePy.defineStruct('::Murmur::ACL', ACL, (), (
        ('applyHere', (), IcePy._t_bool),
        ('applySubs', (), IcePy._t_bool),
        ('inherited', (), IcePy._t_bool),
        ('userid', (), IcePy._t_int),
        ('group', (), IcePy._t_string),
        ('allow', (), IcePy._t_int),
        ('deny', (), IcePy._t_int)
    ))

    _M_Murmur.ACL = ACL
    del ACL

if 'Ban' not in _M_Murmur.__dict__:
    _M_Murmur.Ban = Ice.createTempClass()
    class Ban(object):
        """
        A single ip mask for a ban.
        Members:
        address -- Address to ban.
        bits -- Number of bits in ban to apply.
        name -- Username associated with ban.
        hash -- Hash of banned user.
        reason -- Reason for ban.
        start -- Date ban was applied in unix time format.
        duration -- Duration of ban.
        """
        def __init__(self, address=None, bits=0, name='', hash='', reason='', start=0, duration=0):
            self.address = address
            self.bits = bits
            self.name = name
            self.hash = hash
            self.reason = reason
            self.start = start
            self.duration = duration

        def __hash__(self):
            _h = 0
            if self.address:
                for _i0 in self.address:
                    _h = 5 * _h + Ice.getHash(_i0)
            _h = 5 * _h + Ice.getHash(self.bits)
            _h = 5 * _h + Ice.getHash(self.name)
            _h = 5 * _h + Ice.getHash(self.hash)
            _h = 5 * _h + Ice.getHash(self.reason)
            _h = 5 * _h + Ice.getHash(self.start)
            _h = 5 * _h + Ice.getHash(self.duration)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Murmur.Ban):
                return NotImplemented
            else:
                if self.address is None or other.address is None:
                    if self.address != other.address:
                        return (-1 if self.address is None else 1)
                else:
                    if self.address < other.address:
                        return -1
                    elif self.address > other.address:
                        return 1
                if self.bits is None or other.bits is None:
                    if self.bits != other.bits:
                        return (-1 if self.bits is None else 1)
                else:
                    if self.bits < other.bits:
                        return -1
                    elif self.bits > other.bits:
                        return 1
                if self.name is None or other.name is None:
                    if self.name != other.name:
                        return (-1 if self.name is None else 1)
                else:
                    if self.name < other.name:
                        return -1
                    elif self.name > other.name:
                        return 1
                if self.hash is None or other.hash is None:
                    if self.hash != other.hash:
                        return (-1 if self.hash is None else 1)
                else:
                    if self.hash < other.hash:
                        return -1
                    elif self.hash > other.hash:
                        return 1
                if self.reason is None or other.reason is None:
                    if self.reason != other.reason:
                        return (-1 if self.reason is None else 1)
                else:
                    if self.reason < other.reason:
                        return -1
                    elif self.reason > other.reason:
                        return 1
                if self.start is None or other.start is None:
                    if self.start != other.start:
                        return (-1 if self.start is None else 1)
                else:
                    if self.start < other.start:
                        return -1
                    elif self.start > other.start:
                        return 1
                if self.duration is None or other.duration is None:
                    if self.duration != other.duration:
                        return (-1 if self.duration is None else 1)
                else:
                    if self.duration < other.duration:
                        return -1
                    elif self.duration > other.duration:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_Ban)

        __repr__ = __str__

    _M_Murmur._t_Ban = IcePy.defineStruct('::Murmur::Ban', Ban, (), (
        ('address', (), _M_Murmur._t_NetAddress),
        ('bits', (), IcePy._t_int),
        ('name', (), IcePy._t_string),
        ('hash', (), IcePy._t_string),
        ('reason', (), IcePy._t_string),
        ('start', (), IcePy._t_int),
        ('duration', (), IcePy._t_int)
    ))

    _M_Murmur.Ban = Ban
    del Ban

if 'LogEntry' not in _M_Murmur.__dict__:
    _M_Murmur.LogEntry = Ice.createTempClass()
    class LogEntry(object):
        """
        A entry in the log.
        Members:
        timestamp -- Timestamp in UNIX time_t
        txt -- The log message.
        """
        def __init__(self, timestamp=0, txt=''):
            self.timestamp = timestamp
            self.txt = txt

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.timestamp)
            _h = 5 * _h + Ice.getHash(self.txt)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Murmur.LogEntry):
                return NotImplemented
            else:
                if self.timestamp is None or other.timestamp is None:
                    if self.timestamp != other.timestamp:
                        return (-1 if self.timestamp is None else 1)
                else:
                    if self.timestamp < other.timestamp:
                        return -1
                    elif self.timestamp > other.timestamp:
                        return 1
                if self.txt is None or other.txt is None:
                    if self.txt != other.txt:
                        return (-1 if self.txt is None else 1)
                else:
                    if self.txt < other.txt:
                        return -1
                    elif self.txt > other.txt:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_LogEntry)

        __repr__ = __str__

    _M_Murmur._t_LogEntry = IcePy.defineStruct('::Murmur::LogEntry', LogEntry, (), (
        ('timestamp', (), IcePy._t_int),
        ('txt', (), IcePy._t_string)
    ))

    _M_Murmur.LogEntry = LogEntry
    del LogEntry

if 'Tree' not in _M_Murmur.__dict__:
    _M_Murmur._t_Tree = IcePy.declareValue('::Murmur::Tree')

if '_t_TreeList' not in _M_Murmur.__dict__:
    _M_Murmur._t_TreeList = IcePy.defineSequence('::Murmur::TreeList', (), _M_Murmur._t_Tree)

if 'ChannelInfo' not in _M_Murmur.__dict__:
    _M_Murmur.ChannelInfo = Ice.createTempClass()
    class ChannelInfo(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    ChannelInfo.ChannelDescription = ChannelInfo("ChannelDescription", 0)
    ChannelInfo.ChannelPosition = ChannelInfo("ChannelPosition", 1)
    ChannelInfo._enumerators = { 0:ChannelInfo.ChannelDescription, 1:ChannelInfo.ChannelPosition }

    _M_Murmur._t_ChannelInfo = IcePy.defineEnum('::Murmur::ChannelInfo', ChannelInfo, (), ChannelInfo._enumerators)

    _M_Murmur.ChannelInfo = ChannelInfo
    del ChannelInfo

if 'UserInfo' not in _M_Murmur.__dict__:
    _M_Murmur.UserInfo = Ice.createTempClass()
    class UserInfo(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    UserInfo.UserName = UserInfo("UserName", 0)
    UserInfo.UserEmail = UserInfo("UserEmail", 1)
    UserInfo.UserComment = UserInfo("UserComment", 2)
    UserInfo.UserHash = UserInfo("UserHash", 3)
    UserInfo.UserPassword = UserInfo("UserPassword", 4)
    UserInfo.UserLastActive = UserInfo("UserLastActive", 5)
    UserInfo.UserKDFIterations = UserInfo("UserKDFIterations", 6)
    UserInfo._enumerators = { 0:UserInfo.UserName, 1:UserInfo.UserEmail, 2:UserInfo.UserComment, 3:UserInfo.UserHash, 4:UserInfo.UserPassword, 5:UserInfo.UserLastActive, 6:UserInfo.UserKDFIterations }

    _M_Murmur._t_UserInfo = IcePy.defineEnum('::Murmur::UserInfo', UserInfo, (), UserInfo._enumerators)

    _M_Murmur.UserInfo = UserInfo
    del UserInfo

if '_t_UserMap' not in _M_Murmur.__dict__:
    _M_Murmur._t_UserMap = IcePy.defineDictionary('::Murmur::UserMap', (), IcePy._t_int, _M_Murmur._t_User)

if '_t_ChannelMap' not in _M_Murmur.__dict__:
    _M_Murmur._t_ChannelMap = IcePy.defineDictionary('::Murmur::ChannelMap', (), IcePy._t_int, _M_Murmur._t_Channel)

if '_t_ChannelList' not in _M_Murmur.__dict__:
    _M_Murmur._t_ChannelList = IcePy.defineSequence('::Murmur::ChannelList', (), _M_Murmur._t_Channel)

if '_t_UserList' not in _M_Murmur.__dict__:
    _M_Murmur._t_UserList = IcePy.defineSequence('::Murmur::UserList', (), _M_Murmur._t_User)

if '_t_GroupList' not in _M_Murmur.__dict__:
    _M_Murmur._t_GroupList = IcePy.defineSequence('::Murmur::GroupList', (), _M_Murmur._t_Group)

if '_t_ACLList' not in _M_Murmur.__dict__:
    _M_Murmur._t_ACLList = IcePy.defineSequence('::Murmur::ACLList', (), _M_Murmur._t_ACL)

if '_t_LogList' not in _M_Murmur.__dict__:
    _M_Murmur._t_LogList = IcePy.defineSequence('::Murmur::LogList', (), _M_Murmur._t_LogEntry)

if '_t_BanList' not in _M_Murmur.__dict__:
    _M_Murmur._t_BanList = IcePy.defineSequence('::Murmur::BanList', (), _M_Murmur._t_Ban)

if '_t_IdList' not in _M_Murmur.__dict__:
    _M_Murmur._t_IdList = IcePy.defineSequence('::Murmur::IdList', (), IcePy._t_int)

if '_t_NameList' not in _M_Murmur.__dict__:
    _M_Murmur._t_NameList = IcePy.defineSequence('::Murmur::NameList', (), IcePy._t_string)

if '_t_NameMap' not in _M_Murmur.__dict__:
    _M_Murmur._t_NameMap = IcePy.defineDictionary('::Murmur::NameMap', (), IcePy._t_int, IcePy._t_string)

if '_t_IdMap' not in _M_Murmur.__dict__:
    _M_Murmur._t_IdMap = IcePy.defineDictionary('::Murmur::IdMap', (), IcePy._t_string, IcePy._t_int)

if '_t_Texture' not in _M_Murmur.__dict__:
    _M_Murmur._t_Texture = IcePy.defineSequence('::Murmur::Texture', (), IcePy._t_byte)

if '_t_ConfigMap' not in _M_Murmur.__dict__:
    _M_Murmur._t_ConfigMap = IcePy.defineDictionary('::Murmur::ConfigMap', (), IcePy._t_string, IcePy._t_string)

if '_t_GroupNameList' not in _M_Murmur.__dict__:
    _M_Murmur._t_GroupNameList = IcePy.defineSequence('::Murmur::GroupNameList', (), IcePy._t_string)

if '_t_CertificateDer' not in _M_Murmur.__dict__:
    _M_Murmur._t_CertificateDer = IcePy.defineSequence('::Murmur::CertificateDer', (), IcePy._t_byte)

if '_t_CertificateList' not in _M_Murmur.__dict__:
    _M_Murmur._t_CertificateList = IcePy.defineSequence('::Murmur::CertificateList', (), _M_Murmur._t_CertificateDer)

if '_t_UserInfoMap' not in _M_Murmur.__dict__:
    _M_Murmur._t_UserInfoMap = IcePy.defineDictionary('::Murmur::UserInfoMap', (), _M_Murmur._t_UserInfo, IcePy._t_string)

if 'Tree' not in _M_Murmur.__dict__:
    _M_Murmur.Tree = Ice.createTempClass()
    class Tree(Ice.Value):
        """
        User and subchannel state. Read-only.
        Members:
        c -- Channel definition of current channel.
        children -- List of subchannels.
        users -- Users in this channel.
        """
        def __init__(self, c=Ice._struct_marker, children=None, users=None):
            if c is Ice._struct_marker:
                self.c = _M_Murmur.Channel()
            else:
                self.c = c
            self.children = children
            self.users = users

        def ice_id(self):
            return '::Murmur::Tree'

        @staticmethod
        def ice_staticId():
            return '::Murmur::Tree'

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_Tree)

        __repr__ = __str__

    _M_Murmur._t_Tree = IcePy.defineValue('::Murmur::Tree', Tree, -1, (), False, False, None, (
        ('c', (), _M_Murmur._t_Channel, False, 0),
        ('children', (), _M_Murmur._t_TreeList, False, 0),
        ('users', (), _M_Murmur._t_UserList, False, 0)
    ))
    Tree._ice_type = _M_Murmur._t_Tree

    _M_Murmur.Tree = Tree
    del Tree

if 'MurmurException' not in _M_Murmur.__dict__:
    _M_Murmur.MurmurException = Ice.createTempClass()
    class MurmurException(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Murmur::MurmurException'

    _M_Murmur._t_MurmurException = IcePy.defineException('::Murmur::MurmurException', MurmurException, (), False, None, ())
    MurmurException._ice_type = _M_Murmur._t_MurmurException

    _M_Murmur.MurmurException = MurmurException
    del MurmurException

if 'InvalidSessionException' not in _M_Murmur.__dict__:
    _M_Murmur.InvalidSessionException = Ice.createTempClass()
    class InvalidSessionException(_M_Murmur.MurmurException):
        """
        This is thrown when you specify an invalid session. This may happen if the user has disconnected since your last call to Server.getUsers. See User.session
        """
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Murmur::InvalidSessionException'

    _M_Murmur._t_InvalidSessionException = IcePy.defineException('::Murmur::InvalidSessionException', InvalidSessionException, (), False, _M_Murmur._t_MurmurException, ())
    InvalidSessionException._ice_type = _M_Murmur._t_InvalidSessionException

    _M_Murmur.InvalidSessionException = InvalidSessionException
    del InvalidSessionException

if 'InvalidChannelException' not in _M_Murmur.__dict__:
    _M_Murmur.InvalidChannelException = Ice.createTempClass()
    class InvalidChannelException(_M_Murmur.MurmurException):
        """
        This is thrown when you specify an invalid channel id. This may happen if the channel was removed by another provess. It can also be thrown if you try to add an invalid channel.
        """
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Murmur::InvalidChannelException'

    _M_Murmur._t_InvalidChannelException = IcePy.defineException('::Murmur::InvalidChannelException', InvalidChannelException, (), False, _M_Murmur._t_MurmurException, ())
    InvalidChannelException._ice_type = _M_Murmur._t_InvalidChannelException

    _M_Murmur.InvalidChannelException = InvalidChannelException
    del InvalidChannelException

if 'InvalidServerException' not in _M_Murmur.__dict__:
    _M_Murmur.InvalidServerException = Ice.createTempClass()
    class InvalidServerException(_M_Murmur.MurmurException):
        """
        This is thrown when you try to do an operation on a server that does not exist. This may happen if someone has removed the server.
        """
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Murmur::InvalidServerException'

    _M_Murmur._t_InvalidServerException = IcePy.defineException('::Murmur::InvalidServerException', InvalidServerException, (), False, _M_Murmur._t_MurmurException, ())
    InvalidServerException._ice_type = _M_Murmur._t_InvalidServerException

    _M_Murmur.InvalidServerException = InvalidServerException
    del InvalidServerException

if 'ServerBootedException' not in _M_Murmur.__dict__:
    _M_Murmur.ServerBootedException = Ice.createTempClass()
    class ServerBootedException(_M_Murmur.MurmurException):
        """
        This happens if you try to fetch user or channel state on a stopped server, if you try to stop an already stopped server or start an already started server.
        """
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Murmur::ServerBootedException'

    _M_Murmur._t_ServerBootedException = IcePy.defineException('::Murmur::ServerBootedException', ServerBootedException, (), False, _M_Murmur._t_MurmurException, ())
    ServerBootedException._ice_type = _M_Murmur._t_ServerBootedException

    _M_Murmur.ServerBootedException = ServerBootedException
    del ServerBootedException

if 'ServerFailureException' not in _M_Murmur.__dict__:
    _M_Murmur.ServerFailureException = Ice.createTempClass()
    class ServerFailureException(_M_Murmur.MurmurException):
        """
        This is thrown if Server.start fails, and should generally be the cause for some concern.
        """
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Murmur::ServerFailureException'

    _M_Murmur._t_ServerFailureException = IcePy.defineException('::Murmur::ServerFailureException', ServerFailureException, (), False, _M_Murmur._t_MurmurException, ())
    ServerFailureException._ice_type = _M_Murmur._t_ServerFailureException

    _M_Murmur.ServerFailureException = ServerFailureException
    del ServerFailureException

if 'InvalidUserException' not in _M_Murmur.__dict__:
    _M_Murmur.InvalidUserException = Ice.createTempClass()
    class InvalidUserException(_M_Murmur.MurmurException):
        """
        This is thrown when you specify an invalid userid.
        """
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Murmur::InvalidUserException'

    _M_Murmur._t_InvalidUserException = IcePy.defineException('::Murmur::InvalidUserException', InvalidUserException, (), False, _M_Murmur._t_MurmurException, ())
    InvalidUserException._ice_type = _M_Murmur._t_InvalidUserException

    _M_Murmur.InvalidUserException = InvalidUserException
    del InvalidUserException

if 'InvalidTextureException' not in _M_Murmur.__dict__:
    _M_Murmur.InvalidTextureException = Ice.createTempClass()
    class InvalidTextureException(_M_Murmur.MurmurException):
        """
        This is thrown when you try to set an invalid texture.
        """
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Murmur::InvalidTextureException'

    _M_Murmur._t_InvalidTextureException = IcePy.defineException('::Murmur::InvalidTextureException', InvalidTextureException, (), False, _M_Murmur._t_MurmurException, ())
    InvalidTextureException._ice_type = _M_Murmur._t_InvalidTextureException

    _M_Murmur.InvalidTextureException = InvalidTextureException
    del InvalidTextureException

if 'InvalidCallbackException' not in _M_Murmur.__dict__:
    _M_Murmur.InvalidCallbackException = Ice.createTempClass()
    class InvalidCallbackException(_M_Murmur.MurmurException):
        """
        This is thrown when you supply an invalid callback.
        """
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Murmur::InvalidCallbackException'

    _M_Murmur._t_InvalidCallbackException = IcePy.defineException('::Murmur::InvalidCallbackException', InvalidCallbackException, (), False, _M_Murmur._t_MurmurException, ())
    InvalidCallbackException._ice_type = _M_Murmur._t_InvalidCallbackException

    _M_Murmur.InvalidCallbackException = InvalidCallbackException
    del InvalidCallbackException

if 'InvalidSecretException' not in _M_Murmur.__dict__:
    _M_Murmur.InvalidSecretException = Ice.createTempClass()
    class InvalidSecretException(_M_Murmur.MurmurException):
        """
        This is thrown when you supply the wrong secret in the calling context.
        """
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Murmur::InvalidSecretException'

    _M_Murmur._t_InvalidSecretException = IcePy.defineException('::Murmur::InvalidSecretException', InvalidSecretException, (), False, _M_Murmur._t_MurmurException, ())
    InvalidSecretException._ice_type = _M_Murmur._t_InvalidSecretException

    _M_Murmur.InvalidSecretException = InvalidSecretException
    del InvalidSecretException

if 'NestingLimitException' not in _M_Murmur.__dict__:
    _M_Murmur.NestingLimitException = Ice.createTempClass()
    class NestingLimitException(_M_Murmur.MurmurException):
        """
        This is thrown when the channel operation would exceed the channel nesting limit
        """
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Murmur::NestingLimitException'

    _M_Murmur._t_NestingLimitException = IcePy.defineException('::Murmur::NestingLimitException', NestingLimitException, (), False, _M_Murmur._t_MurmurException, ())
    NestingLimitException._ice_type = _M_Murmur._t_NestingLimitException

    _M_Murmur.NestingLimitException = NestingLimitException
    del NestingLimitException

if 'WriteOnlyException' not in _M_Murmur.__dict__:
    _M_Murmur.WriteOnlyException = Ice.createTempClass()
    class WriteOnlyException(_M_Murmur.MurmurException):
        """
        This is thrown when you ask the server to disclose something that should be secret.
        """
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Murmur::WriteOnlyException'

    _M_Murmur._t_WriteOnlyException = IcePy.defineException('::Murmur::WriteOnlyException', WriteOnlyException, (), False, _M_Murmur._t_MurmurException, ())
    WriteOnlyException._ice_type = _M_Murmur._t_WriteOnlyException

    _M_Murmur.WriteOnlyException = WriteOnlyException
    del WriteOnlyException

if 'InvalidInputDataException' not in _M_Murmur.__dict__:
    _M_Murmur.InvalidInputDataException = Ice.createTempClass()
    class InvalidInputDataException(_M_Murmur.MurmurException):
        """
        This is thrown when invalid input data was specified.
        """
        def __init__(self):
            _M_Murmur.MurmurException.__init__(self)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Murmur::InvalidInputDataException'

    _M_Murmur._t_InvalidInputDataException = IcePy.defineException('::Murmur::InvalidInputDataException', InvalidInputDataException, (), False, _M_Murmur._t_MurmurException, ())
    InvalidInputDataException._ice_type = _M_Murmur._t_InvalidInputDataException

    _M_Murmur.InvalidInputDataException = InvalidInputDataException
    del InvalidInputDataException

_M_Murmur._t_ServerCallback = IcePy.defineValue('::Murmur::ServerCallback', Ice.Value, -1, (), False, True, None, ())

if 'ServerCallbackPrx' not in _M_Murmur.__dict__:
    _M_Murmur.ServerCallbackPrx = Ice.createTempClass()
    class ServerCallbackPrx(Ice.ObjectPrx):

        """
        Called when a user connects to the server.
        Arguments:
        state -- State of connected user.
        context -- The request context for the invocation.
        """
        def userConnected(self, state, context=None):
            return _M_Murmur.ServerCallback._op_userConnected.invoke(self, ((state, ), context))

        """
        Called when a user connects to the server.
        Arguments:
        state -- State of connected user.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def userConnectedAsync(self, state, context=None):
            return _M_Murmur.ServerCallback._op_userConnected.invokeAsync(self, ((state, ), context))

        """
        Called when a user connects to the server.
        Arguments:
        state -- State of connected user.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_userConnected(self, state, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.ServerCallback._op_userConnected.begin(self, ((state, ), _response, _ex, _sent, context))

        """
        Called when a user connects to the server.
        Arguments:
        state -- State of connected user.
        """
        def end_userConnected(self, _r):
            return _M_Murmur.ServerCallback._op_userConnected.end(self, _r)

        """
        Called when a user disconnects from the server. The user has already been removed, so you can no longer use methods like Server.getState
        to retrieve the user's state.
        Arguments:
        state -- State of disconnected user.
        context -- The request context for the invocation.
        """
        def userDisconnected(self, state, context=None):
            return _M_Murmur.ServerCallback._op_userDisconnected.invoke(self, ((state, ), context))

        """
        Called when a user disconnects from the server. The user has already been removed, so you can no longer use methods like Server.getState
        to retrieve the user's state.
        Arguments:
        state -- State of disconnected user.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def userDisconnectedAsync(self, state, context=None):
            return _M_Murmur.ServerCallback._op_userDisconnected.invokeAsync(self, ((state, ), context))

        """
        Called when a user disconnects from the server. The user has already been removed, so you can no longer use methods like Server.getState
        to retrieve the user's state.
        Arguments:
        state -- State of disconnected user.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_userDisconnected(self, state, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.ServerCallback._op_userDisconnected.begin(self, ((state, ), _response, _ex, _sent, context))

        """
        Called when a user disconnects from the server. The user has already been removed, so you can no longer use methods like Server.getState
        to retrieve the user's state.
        Arguments:
        state -- State of disconnected user.
        """
        def end_userDisconnected(self, _r):
            return _M_Murmur.ServerCallback._op_userDisconnected.end(self, _r)

        """
        Called when a user state changes. This is called if the user moves, is renamed, is muted, deafened etc.
        Arguments:
        state -- New state of user.
        context -- The request context for the invocation.
        """
        def userStateChanged(self, state, context=None):
            return _M_Murmur.ServerCallback._op_userStateChanged.invoke(self, ((state, ), context))

        """
        Called when a user state changes. This is called if the user moves, is renamed, is muted, deafened etc.
        Arguments:
        state -- New state of user.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def userStateChangedAsync(self, state, context=None):
            return _M_Murmur.ServerCallback._op_userStateChanged.invokeAsync(self, ((state, ), context))

        """
        Called when a user state changes. This is called if the user moves, is renamed, is muted, deafened etc.
        Arguments:
        state -- New state of user.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_userStateChanged(self, state, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.ServerCallback._op_userStateChanged.begin(self, ((state, ), _response, _ex, _sent, context))

        """
        Called when a user state changes. This is called if the user moves, is renamed, is muted, deafened etc.
        Arguments:
        state -- New state of user.
        """
        def end_userStateChanged(self, _r):
            return _M_Murmur.ServerCallback._op_userStateChanged.end(self, _r)

        """
        Called when user writes a text message
        Arguments:
        state -- the User sending the message
        message -- the TextMessage the user has sent
        context -- The request context for the invocation.
        """
        def userTextMessage(self, state, message, context=None):
            return _M_Murmur.ServerCallback._op_userTextMessage.invoke(self, ((state, message), context))

        """
        Called when user writes a text message
        Arguments:
        state -- the User sending the message
        message -- the TextMessage the user has sent
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def userTextMessageAsync(self, state, message, context=None):
            return _M_Murmur.ServerCallback._op_userTextMessage.invokeAsync(self, ((state, message), context))

        """
        Called when user writes a text message
        Arguments:
        state -- the User sending the message
        message -- the TextMessage the user has sent
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_userTextMessage(self, state, message, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.ServerCallback._op_userTextMessage.begin(self, ((state, message), _response, _ex, _sent, context))

        """
        Called when user writes a text message
        Arguments:
        state -- the User sending the message
        message -- the TextMessage the user has sent
        """
        def end_userTextMessage(self, _r):
            return _M_Murmur.ServerCallback._op_userTextMessage.end(self, _r)

        """
        Called when a new channel is created.
        Arguments:
        state -- State of new channel.
        context -- The request context for the invocation.
        """
        def channelCreated(self, state, context=None):
            return _M_Murmur.ServerCallback._op_channelCreated.invoke(self, ((state, ), context))

        """
        Called when a new channel is created.
        Arguments:
        state -- State of new channel.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def channelCreatedAsync(self, state, context=None):
            return _M_Murmur.ServerCallback._op_channelCreated.invokeAsync(self, ((state, ), context))

        """
        Called when a new channel is created.
        Arguments:
        state -- State of new channel.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_channelCreated(self, state, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.ServerCallback._op_channelCreated.begin(self, ((state, ), _response, _ex, _sent, context))

        """
        Called when a new channel is created.
        Arguments:
        state -- State of new channel.
        """
        def end_channelCreated(self, _r):
            return _M_Murmur.ServerCallback._op_channelCreated.end(self, _r)

        """
        Called when a channel is removed. The channel has already been removed, you can no longer use methods like Server.getChannelState
        Arguments:
        state -- State of removed channel.
        context -- The request context for the invocation.
        """
        def channelRemoved(self, state, context=None):
            return _M_Murmur.ServerCallback._op_channelRemoved.invoke(self, ((state, ), context))

        """
        Called when a channel is removed. The channel has already been removed, you can no longer use methods like Server.getChannelState
        Arguments:
        state -- State of removed channel.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def channelRemovedAsync(self, state, context=None):
            return _M_Murmur.ServerCallback._op_channelRemoved.invokeAsync(self, ((state, ), context))

        """
        Called when a channel is removed. The channel has already been removed, you can no longer use methods like Server.getChannelState
        Arguments:
        state -- State of removed channel.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_channelRemoved(self, state, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.ServerCallback._op_channelRemoved.begin(self, ((state, ), _response, _ex, _sent, context))

        """
        Called when a channel is removed. The channel has already been removed, you can no longer use methods like Server.getChannelState
        Arguments:
        state -- State of removed channel.
        """
        def end_channelRemoved(self, _r):
            return _M_Murmur.ServerCallback._op_channelRemoved.end(self, _r)

        """
        Called when a new channel state changes. This is called if the channel is moved, renamed or if new links are added.
        Arguments:
        state -- New state of channel.
        context -- The request context for the invocation.
        """
        def channelStateChanged(self, state, context=None):
            return _M_Murmur.ServerCallback._op_channelStateChanged.invoke(self, ((state, ), context))

        """
        Called when a new channel state changes. This is called if the channel is moved, renamed or if new links are added.
        Arguments:
        state -- New state of channel.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def channelStateChangedAsync(self, state, context=None):
            return _M_Murmur.ServerCallback._op_channelStateChanged.invokeAsync(self, ((state, ), context))

        """
        Called when a new channel state changes. This is called if the channel is moved, renamed or if new links are added.
        Arguments:
        state -- New state of channel.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_channelStateChanged(self, state, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.ServerCallback._op_channelStateChanged.begin(self, ((state, ), _response, _ex, _sent, context))

        """
        Called when a new channel state changes. This is called if the channel is moved, renamed or if new links are added.
        Arguments:
        state -- New state of channel.
        """
        def end_channelStateChanged(self, _r):
            return _M_Murmur.ServerCallback._op_channelStateChanged.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Murmur.ServerCallbackPrx.ice_checkedCast(proxy, '::Murmur::ServerCallback', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.ServerCallbackPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Murmur::ServerCallback'
    _M_Murmur._t_ServerCallbackPrx = IcePy.defineProxy('::Murmur::ServerCallback', ServerCallbackPrx)

    _M_Murmur.ServerCallbackPrx = ServerCallbackPrx
    del ServerCallbackPrx

    _M_Murmur.ServerCallback = Ice.createTempClass()
    class ServerCallback(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::ServerCallback')

        def ice_id(self, current=None):
            return '::Murmur::ServerCallback'

        @staticmethod
        def ice_staticId():
            return '::Murmur::ServerCallback'

        def userConnected(self, state, current=None):
            """
            Called when a user connects to the server.
            Arguments:
            state -- State of connected user.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'userConnected' not implemented")

        def userDisconnected(self, state, current=None):
            """
            Called when a user disconnects from the server. The user has already been removed, so you can no longer use methods like Server.getState
            to retrieve the user's state.
            Arguments:
            state -- State of disconnected user.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'userDisconnected' not implemented")

        def userStateChanged(self, state, current=None):
            """
            Called when a user state changes. This is called if the user moves, is renamed, is muted, deafened etc.
            Arguments:
            state -- New state of user.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'userStateChanged' not implemented")

        def userTextMessage(self, state, message, current=None):
            """
            Called when user writes a text message
            Arguments:
            state -- the User sending the message
            message -- the TextMessage the user has sent
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'userTextMessage' not implemented")

        def channelCreated(self, state, current=None):
            """
            Called when a new channel is created.
            Arguments:
            state -- State of new channel.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'channelCreated' not implemented")

        def channelRemoved(self, state, current=None):
            """
            Called when a channel is removed. The channel has already been removed, you can no longer use methods like Server.getChannelState
            Arguments:
            state -- State of removed channel.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'channelRemoved' not implemented")

        def channelStateChanged(self, state, current=None):
            """
            Called when a new channel state changes. This is called if the channel is moved, renamed or if new links are added.
            Arguments:
            state -- New state of channel.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'channelStateChanged' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_ServerCallbackDisp)

        __repr__ = __str__

    _M_Murmur._t_ServerCallbackDisp = IcePy.defineClass('::Murmur::ServerCallback', ServerCallback, (), None, ())
    ServerCallback._ice_type = _M_Murmur._t_ServerCallbackDisp

    ServerCallback._op_userConnected = IcePy.Operation('userConnected', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_Murmur._t_User, False, 0),), (), None, ())
    ServerCallback._op_userDisconnected = IcePy.Operation('userDisconnected', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_Murmur._t_User, False, 0),), (), None, ())
    ServerCallback._op_userStateChanged = IcePy.Operation('userStateChanged', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_Murmur._t_User, False, 0),), (), None, ())
    ServerCallback._op_userTextMessage = IcePy.Operation('userTextMessage', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_Murmur._t_User, False, 0), ((), _M_Murmur._t_TextMessage, False, 0)), (), None, ())
    ServerCallback._op_channelCreated = IcePy.Operation('channelCreated', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_Murmur._t_Channel, False, 0),), (), None, ())
    ServerCallback._op_channelRemoved = IcePy.Operation('channelRemoved', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_Murmur._t_Channel, False, 0),), (), None, ())
    ServerCallback._op_channelStateChanged = IcePy.Operation('channelStateChanged', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_Murmur._t_Channel, False, 0),), (), None, ())

    _M_Murmur.ServerCallback = ServerCallback
    del ServerCallback

_M_Murmur.ContextServer = 1

_M_Murmur.ContextChannel = 2

_M_Murmur.ContextUser = 4

_M_Murmur._t_ServerContextCallback = IcePy.defineValue('::Murmur::ServerContextCallback', Ice.Value, -1, (), False, True, None, ())

if 'ServerContextCallbackPrx' not in _M_Murmur.__dict__:
    _M_Murmur.ServerContextCallbackPrx = Ice.createTempClass()
    class ServerContextCallbackPrx(Ice.ObjectPrx):

        """
        Called when a context action is performed.
        Arguments:
        action -- Action to be performed.
        usr -- User which initiated the action.
        session -- If nonzero, session of target user.
        channelid -- If not -1, id of target channel.
        context -- The request context for the invocation.
        """
        def contextAction(self, action, usr, session, channelid, context=None):
            return _M_Murmur.ServerContextCallback._op_contextAction.invoke(self, ((action, usr, session, channelid), context))

        """
        Called when a context action is performed.
        Arguments:
        action -- Action to be performed.
        usr -- User which initiated the action.
        session -- If nonzero, session of target user.
        channelid -- If not -1, id of target channel.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def contextActionAsync(self, action, usr, session, channelid, context=None):
            return _M_Murmur.ServerContextCallback._op_contextAction.invokeAsync(self, ((action, usr, session, channelid), context))

        """
        Called when a context action is performed.
        Arguments:
        action -- Action to be performed.
        usr -- User which initiated the action.
        session -- If nonzero, session of target user.
        channelid -- If not -1, id of target channel.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_contextAction(self, action, usr, session, channelid, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.ServerContextCallback._op_contextAction.begin(self, ((action, usr, session, channelid), _response, _ex, _sent, context))

        """
        Called when a context action is performed.
        Arguments:
        action -- Action to be performed.
        usr -- User which initiated the action.
        session -- If nonzero, session of target user.
        channelid -- If not -1, id of target channel.
        """
        def end_contextAction(self, _r):
            return _M_Murmur.ServerContextCallback._op_contextAction.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Murmur.ServerContextCallbackPrx.ice_checkedCast(proxy, '::Murmur::ServerContextCallback', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.ServerContextCallbackPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Murmur::ServerContextCallback'
    _M_Murmur._t_ServerContextCallbackPrx = IcePy.defineProxy('::Murmur::ServerContextCallback', ServerContextCallbackPrx)

    _M_Murmur.ServerContextCallbackPrx = ServerContextCallbackPrx
    del ServerContextCallbackPrx

    _M_Murmur.ServerContextCallback = Ice.createTempClass()
    class ServerContextCallback(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::ServerContextCallback')

        def ice_id(self, current=None):
            return '::Murmur::ServerContextCallback'

        @staticmethod
        def ice_staticId():
            return '::Murmur::ServerContextCallback'

        def contextAction(self, action, usr, session, channelid, current=None):
            """
            Called when a context action is performed.
            Arguments:
            action -- Action to be performed.
            usr -- User which initiated the action.
            session -- If nonzero, session of target user.
            channelid -- If not -1, id of target channel.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'contextAction' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_ServerContextCallbackDisp)

        __repr__ = __str__

    _M_Murmur._t_ServerContextCallbackDisp = IcePy.defineClass('::Murmur::ServerContextCallback', ServerContextCallback, (), None, ())
    ServerContextCallback._ice_type = _M_Murmur._t_ServerContextCallbackDisp

    ServerContextCallback._op_contextAction = IcePy.Operation('contextAction', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_string, False, 0), ((), _M_Murmur._t_User, False, 0), ((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), None, ())

    _M_Murmur.ServerContextCallback = ServerContextCallback
    del ServerContextCallback

_M_Murmur._t_ServerAuthenticator = IcePy.defineValue('::Murmur::ServerAuthenticator', Ice.Value, -1, (), False, True, None, ())

if 'ServerAuthenticatorPrx' not in _M_Murmur.__dict__:
    _M_Murmur.ServerAuthenticatorPrx = Ice.createTempClass()
    class ServerAuthenticatorPrx(Ice.ObjectPrx):

        """
        Called to authenticate a user. If you do not know the username in question, always return -2 from this
        method to fall through to normal database authentication.
        Note that if authentication succeeds, murmur will create a record of the user in it's database, reserving
        the username and id so it cannot be used for normal database authentication.
        The data in the certificate (name, email addresses etc), as well as the list of signing certificates,
        should only be trusted if certstrong is true.
        Internally, Murmur treats usernames as case-insensitive. It is recommended
        that authenticators do the same. Murmur checks if a username is in use when
        a user connects. If the connecting user is registered, the other username is
        kicked. If the connecting user is not registered, the connecting user is not
        allowed to join the server.
        Arguments:
        name -- Username to authenticate.
        pw -- Password to authenticate with.
        certificates -- List of der encoded certificates the user connected with.
        certhash -- Hash of user certificate, as used by murmur internally when matching.
        certstrong -- True if certificate was valid and signed by a trusted CA.
        context -- The request context for the invocation.
        Returns a tuple containing the following:
        _retval -- UserID of authenticated user, -1 for authentication failures, -2 for unknown user (fallthrough), -3 for authentication failures where the data could (temporarily) not be verified.
        newname -- Set this to change the username from the supplied one.
        groups -- List of groups on the root channel that the user will be added to for the duration of the connection.
        """
        def authenticate(self, name, pw, certificates, certhash, certstrong, context=None):
            return _M_Murmur.ServerAuthenticator._op_authenticate.invoke(self, ((name, pw, certificates, certhash, certstrong), context))

        """
        Called to authenticate a user. If you do not know the username in question, always return -2 from this
        method to fall through to normal database authentication.
        Note that if authentication succeeds, murmur will create a record of the user in it's database, reserving
        the username and id so it cannot be used for normal database authentication.
        The data in the certificate (name, email addresses etc), as well as the list of signing certificates,
        should only be trusted if certstrong is true.
        Internally, Murmur treats usernames as case-insensitive. It is recommended
        that authenticators do the same. Murmur checks if a username is in use when
        a user connects. If the connecting user is registered, the other username is
        kicked. If the connecting user is not registered, the connecting user is not
        allowed to join the server.
        Arguments:
        name -- Username to authenticate.
        pw -- Password to authenticate with.
        certificates -- List of der encoded certificates the user connected with.
        certhash -- Hash of user certificate, as used by murmur internally when matching.
        certstrong -- True if certificate was valid and signed by a trusted CA.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def authenticateAsync(self, name, pw, certificates, certhash, certstrong, context=None):
            return _M_Murmur.ServerAuthenticator._op_authenticate.invokeAsync(self, ((name, pw, certificates, certhash, certstrong), context))

        """
        Called to authenticate a user. If you do not know the username in question, always return -2 from this
        method to fall through to normal database authentication.
        Note that if authentication succeeds, murmur will create a record of the user in it's database, reserving
        the username and id so it cannot be used for normal database authentication.
        The data in the certificate (name, email addresses etc), as well as the list of signing certificates,
        should only be trusted if certstrong is true.
        Internally, Murmur treats usernames as case-insensitive. It is recommended
        that authenticators do the same. Murmur checks if a username is in use when
        a user connects. If the connecting user is registered, the other username is
        kicked. If the connecting user is not registered, the connecting user is not
        allowed to join the server.
        Arguments:
        name -- Username to authenticate.
        pw -- Password to authenticate with.
        certificates -- List of der encoded certificates the user connected with.
        certhash -- Hash of user certificate, as used by murmur internally when matching.
        certstrong -- True if certificate was valid and signed by a trusted CA.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_authenticate(self, name, pw, certificates, certhash, certstrong, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.ServerAuthenticator._op_authenticate.begin(self, ((name, pw, certificates, certhash, certstrong), _response, _ex, _sent, context))

        """
        Called to authenticate a user. If you do not know the username in question, always return -2 from this
        method to fall through to normal database authentication.
        Note that if authentication succeeds, murmur will create a record of the user in it's database, reserving
        the username and id so it cannot be used for normal database authentication.
        The data in the certificate (name, email addresses etc), as well as the list of signing certificates,
        should only be trusted if certstrong is true.
        Internally, Murmur treats usernames as case-insensitive. It is recommended
        that authenticators do the same. Murmur checks if a username is in use when
        a user connects. If the connecting user is registered, the other username is
        kicked. If the connecting user is not registered, the connecting user is not
        allowed to join the server.
        Arguments:
        name -- Username to authenticate.
        pw -- Password to authenticate with.
        certificates -- List of der encoded certificates the user connected with.
        certhash -- Hash of user certificate, as used by murmur internally when matching.
        certstrong -- True if certificate was valid and signed by a trusted CA.
        Returns a tuple containing the following:
        _retval -- UserID of authenticated user, -1 for authentication failures, -2 for unknown user (fallthrough), -3 for authentication failures where the data could (temporarily) not be verified.
        newname -- Set this to change the username from the supplied one.
        groups -- List of groups on the root channel that the user will be added to for the duration of the connection.
        """
        def end_authenticate(self, _r):
            return _M_Murmur.ServerAuthenticator._op_authenticate.end(self, _r)

        """
        Fetch information about a user. This is used to retrieve information like email address, keyhash etc. If you
        want murmur to take care of this information itself, simply return false to fall through.
        Arguments:
        id -- User id.
        context -- The request context for the invocation.
        Returns a tuple containing the following:
        _retval -- true if information is present, false to fall through.
        info -- Information about user. This needs to include at least "name".
        """
        def getInfo(self, id, context=None):
            return _M_Murmur.ServerAuthenticator._op_getInfo.invoke(self, ((id, ), context))

        """
        Fetch information about a user. This is used to retrieve information like email address, keyhash etc. If you
        want murmur to take care of this information itself, simply return false to fall through.
        Arguments:
        id -- User id.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getInfoAsync(self, id, context=None):
            return _M_Murmur.ServerAuthenticator._op_getInfo.invokeAsync(self, ((id, ), context))

        """
        Fetch information about a user. This is used to retrieve information like email address, keyhash etc. If you
        want murmur to take care of this information itself, simply return false to fall through.
        Arguments:
        id -- User id.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getInfo(self, id, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.ServerAuthenticator._op_getInfo.begin(self, ((id, ), _response, _ex, _sent, context))

        """
        Fetch information about a user. This is used to retrieve information like email address, keyhash etc. If you
        want murmur to take care of this information itself, simply return false to fall through.
        Arguments:
        id -- User id.
        Returns a tuple containing the following:
        _retval -- true if information is present, false to fall through.
        info -- Information about user. This needs to include at least "name".
        """
        def end_getInfo(self, _r):
            return _M_Murmur.ServerAuthenticator._op_getInfo.end(self, _r)

        """
        Map a name to a user id.
        Arguments:
        name -- Username to map.
        context -- The request context for the invocation.
        Returns: User id or -2 for unknown name.
        """
        def nameToId(self, name, context=None):
            return _M_Murmur.ServerAuthenticator._op_nameToId.invoke(self, ((name, ), context))

        """
        Map a name to a user id.
        Arguments:
        name -- Username to map.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def nameToIdAsync(self, name, context=None):
            return _M_Murmur.ServerAuthenticator._op_nameToId.invokeAsync(self, ((name, ), context))

        """
        Map a name to a user id.
        Arguments:
        name -- Username to map.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_nameToId(self, name, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.ServerAuthenticator._op_nameToId.begin(self, ((name, ), _response, _ex, _sent, context))

        """
        Map a name to a user id.
        Arguments:
        name -- Username to map.
        Returns: User id or -2 for unknown name.
        """
        def end_nameToId(self, _r):
            return _M_Murmur.ServerAuthenticator._op_nameToId.end(self, _r)

        """
        Map a user id to a username.
        Arguments:
        id -- User id to map.
        context -- The request context for the invocation.
        Returns: Name of user or empty string for unknown id.
        """
        def idToName(self, id, context=None):
            return _M_Murmur.ServerAuthenticator._op_idToName.invoke(self, ((id, ), context))

        """
        Map a user id to a username.
        Arguments:
        id -- User id to map.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def idToNameAsync(self, id, context=None):
            return _M_Murmur.ServerAuthenticator._op_idToName.invokeAsync(self, ((id, ), context))

        """
        Map a user id to a username.
        Arguments:
        id -- User id to map.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_idToName(self, id, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.ServerAuthenticator._op_idToName.begin(self, ((id, ), _response, _ex, _sent, context))

        """
        Map a user id to a username.
        Arguments:
        id -- User id to map.
        Returns: Name of user or empty string for unknown id.
        """
        def end_idToName(self, _r):
            return _M_Murmur.ServerAuthenticator._op_idToName.end(self, _r)

        """
        Map a user to a custom Texture.
        Arguments:
        id -- User id to map.
        context -- The request context for the invocation.
        Returns: User texture or an empty texture for unknown users or users without textures.
        """
        def idToTexture(self, id, context=None):
            return _M_Murmur.ServerAuthenticator._op_idToTexture.invoke(self, ((id, ), context))

        """
        Map a user to a custom Texture.
        Arguments:
        id -- User id to map.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def idToTextureAsync(self, id, context=None):
            return _M_Murmur.ServerAuthenticator._op_idToTexture.invokeAsync(self, ((id, ), context))

        """
        Map a user to a custom Texture.
        Arguments:
        id -- User id to map.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_idToTexture(self, id, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.ServerAuthenticator._op_idToTexture.begin(self, ((id, ), _response, _ex, _sent, context))

        """
        Map a user to a custom Texture.
        Arguments:
        id -- User id to map.
        Returns: User texture or an empty texture for unknown users or users without textures.
        """
        def end_idToTexture(self, _r):
            return _M_Murmur.ServerAuthenticator._op_idToTexture.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Murmur.ServerAuthenticatorPrx.ice_checkedCast(proxy, '::Murmur::ServerAuthenticator', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.ServerAuthenticatorPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Murmur::ServerAuthenticator'
    _M_Murmur._t_ServerAuthenticatorPrx = IcePy.defineProxy('::Murmur::ServerAuthenticator', ServerAuthenticatorPrx)

    _M_Murmur.ServerAuthenticatorPrx = ServerAuthenticatorPrx
    del ServerAuthenticatorPrx

    _M_Murmur.ServerAuthenticator = Ice.createTempClass()
    class ServerAuthenticator(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::ServerAuthenticator')

        def ice_id(self, current=None):
            return '::Murmur::ServerAuthenticator'

        @staticmethod
        def ice_staticId():
            return '::Murmur::ServerAuthenticator'

        def authenticate(self, name, pw, certificates, certhash, certstrong, current=None):
            """
            Called to authenticate a user. If you do not know the username in question, always return -2 from this
            method to fall through to normal database authentication.
            Note that if authentication succeeds, murmur will create a record of the user in it's database, reserving
            the username and id so it cannot be used for normal database authentication.
            The data in the certificate (name, email addresses etc), as well as the list of signing certificates,
            should only be trusted if certstrong is true.
            Internally, Murmur treats usernames as case-insensitive. It is recommended
            that authenticators do the same. Murmur checks if a username is in use when
            a user connects. If the connecting user is registered, the other username is
            kicked. If the connecting user is not registered, the connecting user is not
            allowed to join the server.
            Arguments:
            name -- Username to authenticate.
            pw -- Password to authenticate with.
            certificates -- List of der encoded certificates the user connected with.
            certhash -- Hash of user certificate, as used by murmur internally when matching.
            certstrong -- True if certificate was valid and signed by a trusted CA.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'authenticate' not implemented")

        def getInfo(self, id, current=None):
            """
            Fetch information about a user. This is used to retrieve information like email address, keyhash etc. If you
            want murmur to take care of this information itself, simply return false to fall through.
            Arguments:
            id -- User id.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getInfo' not implemented")

        def nameToId(self, name, current=None):
            """
            Map a name to a user id.
            Arguments:
            name -- Username to map.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'nameToId' not implemented")

        def idToName(self, id, current=None):
            """
            Map a user id to a username.
            Arguments:
            id -- User id to map.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'idToName' not implemented")

        def idToTexture(self, id, current=None):
            """
            Map a user to a custom Texture.
            Arguments:
            id -- User id to map.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'idToTexture' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_ServerAuthenticatorDisp)

        __repr__ = __str__

    _M_Murmur._t_ServerAuthenticatorDisp = IcePy.defineClass('::Murmur::ServerAuthenticator', ServerAuthenticator, (), None, ())
    ServerAuthenticator._ice_type = _M_Murmur._t_ServerAuthenticatorDisp

    ServerAuthenticator._op_authenticate = IcePy.Operation('authenticate', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), _M_Murmur._t_CertificateList, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_bool, False, 0)), (((), IcePy._t_string, False, 0), ((), _M_Murmur._t_GroupNameList, False, 0)), ((), IcePy._t_int, False, 0), ())
    ServerAuthenticator._op_getInfo = IcePy.Operation('getInfo', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_int, False, 0),), (((), _M_Murmur._t_UserInfoMap, False, 0),), ((), IcePy._t_bool, False, 0), ())
    ServerAuthenticator._op_nameToId = IcePy.Operation('nameToId', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_string, False, 0),), (), ((), IcePy._t_int, False, 0), ())
    ServerAuthenticator._op_idToName = IcePy.Operation('idToName', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_int, False, 0),), (), ((), IcePy._t_string, False, 0), ())
    ServerAuthenticator._op_idToTexture = IcePy.Operation('idToTexture', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_int, False, 0),), (), ((), _M_Murmur._t_Texture, False, 0), ())

    _M_Murmur.ServerAuthenticator = ServerAuthenticator
    del ServerAuthenticator

_M_Murmur._t_ServerUpdatingAuthenticator = IcePy.defineValue('::Murmur::ServerUpdatingAuthenticator', Ice.Value, -1, (), False, True, None, ())

if 'ServerUpdatingAuthenticatorPrx' not in _M_Murmur.__dict__:
    _M_Murmur.ServerUpdatingAuthenticatorPrx = Ice.createTempClass()
    class ServerUpdatingAuthenticatorPrx(_M_Murmur.ServerAuthenticatorPrx):

        """
        Register a new user.
        Arguments:
        info -- Information about user to register.
        context -- The request context for the invocation.
        Returns: User id of new user, -1 for registration failure, or -2 to fall through.
        """
        def registerUser(self, info, context=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_registerUser.invoke(self, ((info, ), context))

        """
        Register a new user.
        Arguments:
        info -- Information about user to register.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def registerUserAsync(self, info, context=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_registerUser.invokeAsync(self, ((info, ), context))

        """
        Register a new user.
        Arguments:
        info -- Information about user to register.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_registerUser(self, info, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_registerUser.begin(self, ((info, ), _response, _ex, _sent, context))

        """
        Register a new user.
        Arguments:
        info -- Information about user to register.
        Returns: User id of new user, -1 for registration failure, or -2 to fall through.
        """
        def end_registerUser(self, _r):
            return _M_Murmur.ServerUpdatingAuthenticator._op_registerUser.end(self, _r)

        """
        Unregister a user.
        Arguments:
        id -- Userid to unregister.
        context -- The request context for the invocation.
        Returns: 1 for successful unregistration, 0 for unsuccessful unregistration, -1 to fall through.
        """
        def unregisterUser(self, id, context=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_unregisterUser.invoke(self, ((id, ), context))

        """
        Unregister a user.
        Arguments:
        id -- Userid to unregister.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def unregisterUserAsync(self, id, context=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_unregisterUser.invokeAsync(self, ((id, ), context))

        """
        Unregister a user.
        Arguments:
        id -- Userid to unregister.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_unregisterUser(self, id, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_unregisterUser.begin(self, ((id, ), _response, _ex, _sent, context))

        """
        Unregister a user.
        Arguments:
        id -- Userid to unregister.
        Returns: 1 for successful unregistration, 0 for unsuccessful unregistration, -1 to fall through.
        """
        def end_unregisterUser(self, _r):
            return _M_Murmur.ServerUpdatingAuthenticator._op_unregisterUser.end(self, _r)

        """
        Get a list of registered users matching filter.
        Arguments:
        filter -- Substring usernames must contain. If empty, return all registered users.
        context -- The request context for the invocation.
        Returns: List of matching registered users.
        """
        def getRegisteredUsers(self, filter, context=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_getRegisteredUsers.invoke(self, ((filter, ), context))

        """
        Get a list of registered users matching filter.
        Arguments:
        filter -- Substring usernames must contain. If empty, return all registered users.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getRegisteredUsersAsync(self, filter, context=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_getRegisteredUsers.invokeAsync(self, ((filter, ), context))

        """
        Get a list of registered users matching filter.
        Arguments:
        filter -- Substring usernames must contain. If empty, return all registered users.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getRegisteredUsers(self, filter, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_getRegisteredUsers.begin(self, ((filter, ), _response, _ex, _sent, context))

        """
        Get a list of registered users matching filter.
        Arguments:
        filter -- Substring usernames must contain. If empty, return all registered users.
        Returns: List of matching registered users.
        """
        def end_getRegisteredUsers(self, _r):
            return _M_Murmur.ServerUpdatingAuthenticator._op_getRegisteredUsers.end(self, _r)

        """
        Set additional information for user registration.
        Arguments:
        id -- Userid of registered user.
        info -- Information to set about user. This should be merged with existing information.
        context -- The request context for the invocation.
        Returns: 1 for successful update, 0 for unsuccessful update, -1 to fall through.
        """
        def setInfo(self, id, info, context=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_setInfo.invoke(self, ((id, info), context))

        """
        Set additional information for user registration.
        Arguments:
        id -- Userid of registered user.
        info -- Information to set about user. This should be merged with existing information.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def setInfoAsync(self, id, info, context=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_setInfo.invokeAsync(self, ((id, info), context))

        """
        Set additional information for user registration.
        Arguments:
        id -- Userid of registered user.
        info -- Information to set about user. This should be merged with existing information.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_setInfo(self, id, info, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_setInfo.begin(self, ((id, info), _response, _ex, _sent, context))

        """
        Set additional information for user registration.
        Arguments:
        id -- Userid of registered user.
        info -- Information to set about user. This should be merged with existing information.
        Returns: 1 for successful update, 0 for unsuccessful update, -1 to fall through.
        """
        def end_setInfo(self, _r):
            return _M_Murmur.ServerUpdatingAuthenticator._op_setInfo.end(self, _r)

        """
        Set texture (now called avatar) of user registration.
        Arguments:
        id -- registrationId of registered user.
        tex -- New texture.
        context -- The request context for the invocation.
        Returns: 1 for successful update, 0 for unsuccessful update, -1 to fall through.
        """
        def setTexture(self, id, tex, context=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_setTexture.invoke(self, ((id, tex), context))

        """
        Set texture (now called avatar) of user registration.
        Arguments:
        id -- registrationId of registered user.
        tex -- New texture.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def setTextureAsync(self, id, tex, context=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_setTexture.invokeAsync(self, ((id, tex), context))

        """
        Set texture (now called avatar) of user registration.
        Arguments:
        id -- registrationId of registered user.
        tex -- New texture.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_setTexture(self, id, tex, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.ServerUpdatingAuthenticator._op_setTexture.begin(self, ((id, tex), _response, _ex, _sent, context))

        """
        Set texture (now called avatar) of user registration.
        Arguments:
        id -- registrationId of registered user.
        tex -- New texture.
        Returns: 1 for successful update, 0 for unsuccessful update, -1 to fall through.
        """
        def end_setTexture(self, _r):
            return _M_Murmur.ServerUpdatingAuthenticator._op_setTexture.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Murmur.ServerUpdatingAuthenticatorPrx.ice_checkedCast(proxy, '::Murmur::ServerUpdatingAuthenticator', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.ServerUpdatingAuthenticatorPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Murmur::ServerUpdatingAuthenticator'
    _M_Murmur._t_ServerUpdatingAuthenticatorPrx = IcePy.defineProxy('::Murmur::ServerUpdatingAuthenticator', ServerUpdatingAuthenticatorPrx)

    _M_Murmur.ServerUpdatingAuthenticatorPrx = ServerUpdatingAuthenticatorPrx
    del ServerUpdatingAuthenticatorPrx

    _M_Murmur.ServerUpdatingAuthenticator = Ice.createTempClass()
    class ServerUpdatingAuthenticator(_M_Murmur.ServerAuthenticator):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::ServerAuthenticator', '::Murmur::ServerUpdatingAuthenticator')

        def ice_id(self, current=None):
            return '::Murmur::ServerUpdatingAuthenticator'

        @staticmethod
        def ice_staticId():
            return '::Murmur::ServerUpdatingAuthenticator'

        def registerUser(self, info, current=None):
            """
            Register a new user.
            Arguments:
            info -- Information about user to register.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'registerUser' not implemented")

        def unregisterUser(self, id, current=None):
            """
            Unregister a user.
            Arguments:
            id -- Userid to unregister.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'unregisterUser' not implemented")

        def getRegisteredUsers(self, filter, current=None):
            """
            Get a list of registered users matching filter.
            Arguments:
            filter -- Substring usernames must contain. If empty, return all registered users.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getRegisteredUsers' not implemented")

        def setInfo(self, id, info, current=None):
            """
            Set additional information for user registration.
            Arguments:
            id -- Userid of registered user.
            info -- Information to set about user. This should be merged with existing information.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'setInfo' not implemented")

        def setTexture(self, id, tex, current=None):
            """
            Set texture (now called avatar) of user registration.
            Arguments:
            id -- registrationId of registered user.
            tex -- New texture.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'setTexture' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_ServerUpdatingAuthenticatorDisp)

        __repr__ = __str__

    _M_Murmur._t_ServerUpdatingAuthenticatorDisp = IcePy.defineClass('::Murmur::ServerUpdatingAuthenticator', ServerUpdatingAuthenticator, (), None, (_M_Murmur._t_ServerAuthenticatorDisp,))
    ServerUpdatingAuthenticator._ice_type = _M_Murmur._t_ServerUpdatingAuthenticatorDisp

    ServerUpdatingAuthenticator._op_registerUser = IcePy.Operation('registerUser', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Murmur._t_UserInfoMap, False, 0),), (), ((), IcePy._t_int, False, 0), ())
    ServerUpdatingAuthenticator._op_unregisterUser = IcePy.Operation('unregisterUser', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0),), (), ((), IcePy._t_int, False, 0), ())
    ServerUpdatingAuthenticator._op_getRegisteredUsers = IcePy.Operation('getRegisteredUsers', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_string, False, 0),), (), ((), _M_Murmur._t_NameMap, False, 0), ())
    ServerUpdatingAuthenticator._op_setInfo = IcePy.Operation('setInfo', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_int, False, 0), ((), _M_Murmur._t_UserInfoMap, False, 0)), (), ((), IcePy._t_int, False, 0), ())
    ServerUpdatingAuthenticator._op_setTexture = IcePy.Operation('setTexture', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_int, False, 0), ((), _M_Murmur._t_Texture, False, 0)), (), ((), IcePy._t_int, False, 0), ())

    _M_Murmur.ServerUpdatingAuthenticator = ServerUpdatingAuthenticator
    del ServerUpdatingAuthenticator

_M_Murmur._t_Server = IcePy.defineValue('::Murmur::Server', Ice.Value, -1, (), False, True, None, ())

if 'ServerPrx' not in _M_Murmur.__dict__:
    _M_Murmur.ServerPrx = Ice.createTempClass()
    class ServerPrx(Ice.ObjectPrx):

        """
        Shows if the server currently running (accepting users).
        Arguments:
        context -- The request context for the invocation.
        Returns: Run-state of server.
        """
        def isRunning(self, context=None):
            return _M_Murmur.Server._op_isRunning.invoke(self, ((), context))

        """
        Shows if the server currently running (accepting users).
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def isRunningAsync(self, context=None):
            return _M_Murmur.Server._op_isRunning.invokeAsync(self, ((), context))

        """
        Shows if the server currently running (accepting users).
        Arguments:
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_isRunning(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_isRunning.begin(self, ((), _response, _ex, _sent, context))

        """
        Shows if the server currently running (accepting users).
        Arguments:
        Returns: Run-state of server.
        """
        def end_isRunning(self, _r):
            return _M_Murmur.Server._op_isRunning.end(self, _r)

        """
        Start server.
        Arguments:
        context -- The request context for the invocation.
        """
        def start(self, context=None):
            return _M_Murmur.Server._op_start.invoke(self, ((), context))

        """
        Start server.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def startAsync(self, context=None):
            return _M_Murmur.Server._op_start.invokeAsync(self, ((), context))

        """
        Start server.
        Arguments:
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_start(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_start.begin(self, ((), _response, _ex, _sent, context))

        """
        Start server.
        Arguments:
        """
        def end_start(self, _r):
            return _M_Murmur.Server._op_start.end(self, _r)

        """
        Stop server.
        Note: Server will be restarted on Murmur restart unless explicitly disabled
        with setConf("boot", false)
        Arguments:
        context -- The request context for the invocation.
        """
        def stop(self, context=None):
            return _M_Murmur.Server._op_stop.invoke(self, ((), context))

        """
        Stop server.
        Note: Server will be restarted on Murmur restart unless explicitly disabled
        with setConf("boot", false)
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def stopAsync(self, context=None):
            return _M_Murmur.Server._op_stop.invokeAsync(self, ((), context))

        """
        Stop server.
        Note: Server will be restarted on Murmur restart unless explicitly disabled
        with setConf("boot", false)
        Arguments:
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_stop(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_stop.begin(self, ((), _response, _ex, _sent, context))

        """
        Stop server.
        Note: Server will be restarted on Murmur restart unless explicitly disabled
        with setConf("boot", false)
        Arguments:
        """
        def end_stop(self, _r):
            return _M_Murmur.Server._op_stop.end(self, _r)

        """
        Delete server and all it's configuration.
        Arguments:
        context -- The request context for the invocation.
        """
        def delete(self, context=None):
            return _M_Murmur.Server._op_delete.invoke(self, ((), context))

        """
        Delete server and all it's configuration.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def deleteAsync(self, context=None):
            return _M_Murmur.Server._op_delete.invokeAsync(self, ((), context))

        """
        Delete server and all it's configuration.
        Arguments:
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_delete(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_delete.begin(self, ((), _response, _ex, _sent, context))

        """
        Delete server and all it's configuration.
        Arguments:
        """
        def end_delete(self, _r):
            return _M_Murmur.Server._op_delete.end(self, _r)

        """
        Fetch the server id.
        Arguments:
        context -- The request context for the invocation.
        Returns: Unique server id.
        """
        def id(self, context=None):
            return _M_Murmur.Server._op_id.invoke(self, ((), context))

        """
        Fetch the server id.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def idAsync(self, context=None):
            return _M_Murmur.Server._op_id.invokeAsync(self, ((), context))

        """
        Fetch the server id.
        Arguments:
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_id(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_id.begin(self, ((), _response, _ex, _sent, context))

        """
        Fetch the server id.
        Arguments:
        Returns: Unique server id.
        """
        def end_id(self, _r):
            return _M_Murmur.Server._op_id.end(self, _r)

        """
        Add a callback. The callback will receive notifications about changes to users and channels.
        Arguments:
        cb -- Callback interface which will receive notifications.
        context -- The request context for the invocation.
        """
        def addCallback(self, cb, context=None):
            return _M_Murmur.Server._op_addCallback.invoke(self, ((cb, ), context))

        """
        Add a callback. The callback will receive notifications about changes to users and channels.
        Arguments:
        cb -- Callback interface which will receive notifications.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def addCallbackAsync(self, cb, context=None):
            return _M_Murmur.Server._op_addCallback.invokeAsync(self, ((cb, ), context))

        """
        Add a callback. The callback will receive notifications about changes to users and channels.
        Arguments:
        cb -- Callback interface which will receive notifications.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_addCallback(self, cb, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_addCallback.begin(self, ((cb, ), _response, _ex, _sent, context))

        """
        Add a callback. The callback will receive notifications about changes to users and channels.
        Arguments:
        cb -- Callback interface which will receive notifications.
        """
        def end_addCallback(self, _r):
            return _M_Murmur.Server._op_addCallback.end(self, _r)

        """
        Remove a callback.
        Arguments:
        cb -- Callback interface to be removed.
        context -- The request context for the invocation.
        """
        def removeCallback(self, cb, context=None):
            return _M_Murmur.Server._op_removeCallback.invoke(self, ((cb, ), context))

        """
        Remove a callback.
        Arguments:
        cb -- Callback interface to be removed.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def removeCallbackAsync(self, cb, context=None):
            return _M_Murmur.Server._op_removeCallback.invokeAsync(self, ((cb, ), context))

        """
        Remove a callback.
        Arguments:
        cb -- Callback interface to be removed.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_removeCallback(self, cb, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_removeCallback.begin(self, ((cb, ), _response, _ex, _sent, context))

        """
        Remove a callback.
        Arguments:
        cb -- Callback interface to be removed.
        """
        def end_removeCallback(self, _r):
            return _M_Murmur.Server._op_removeCallback.end(self, _r)

        """
        Set external authenticator. If set, all authentications from clients are forwarded to this
        proxy.
        Arguments:
        auth -- Authenticator object to perform subsequent authentications.
        context -- The request context for the invocation.
        """
        def setAuthenticator(self, auth, context=None):
            return _M_Murmur.Server._op_setAuthenticator.invoke(self, ((auth, ), context))

        """
        Set external authenticator. If set, all authentications from clients are forwarded to this
        proxy.
        Arguments:
        auth -- Authenticator object to perform subsequent authentications.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def setAuthenticatorAsync(self, auth, context=None):
            return _M_Murmur.Server._op_setAuthenticator.invokeAsync(self, ((auth, ), context))

        """
        Set external authenticator. If set, all authentications from clients are forwarded to this
        proxy.
        Arguments:
        auth -- Authenticator object to perform subsequent authentications.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_setAuthenticator(self, auth, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_setAuthenticator.begin(self, ((auth, ), _response, _ex, _sent, context))

        """
        Set external authenticator. If set, all authentications from clients are forwarded to this
        proxy.
        Arguments:
        auth -- Authenticator object to perform subsequent authentications.
        """
        def end_setAuthenticator(self, _r):
            return _M_Murmur.Server._op_setAuthenticator.end(self, _r)

        """
        Retrieve configuration item.
        Arguments:
        key -- Configuration key.
        context -- The request context for the invocation.
        Returns: Configuration value. If this is empty, see Meta.getDefaultConf
        """
        def getConf(self, key, context=None):
            return _M_Murmur.Server._op_getConf.invoke(self, ((key, ), context))

        """
        Retrieve configuration item.
        Arguments:
        key -- Configuration key.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getConfAsync(self, key, context=None):
            return _M_Murmur.Server._op_getConf.invokeAsync(self, ((key, ), context))

        """
        Retrieve configuration item.
        Arguments:
        key -- Configuration key.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getConf(self, key, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_getConf.begin(self, ((key, ), _response, _ex, _sent, context))

        """
        Retrieve configuration item.
        Arguments:
        key -- Configuration key.
        Returns: Configuration value. If this is empty, see Meta.getDefaultConf
        """
        def end_getConf(self, _r):
            return _M_Murmur.Server._op_getConf.end(self, _r)

        """
        Retrieve all configuration items.
        Arguments:
        context -- The request context for the invocation.
        Returns: All configured values. If a value isn't set here, the value from Meta.getDefaultConf is used.
        """
        def getAllConf(self, context=None):
            return _M_Murmur.Server._op_getAllConf.invoke(self, ((), context))

        """
        Retrieve all configuration items.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getAllConfAsync(self, context=None):
            return _M_Murmur.Server._op_getAllConf.invokeAsync(self, ((), context))

        """
        Retrieve all configuration items.
        Arguments:
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getAllConf(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_getAllConf.begin(self, ((), _response, _ex, _sent, context))

        """
        Retrieve all configuration items.
        Arguments:
        Returns: All configured values. If a value isn't set here, the value from Meta.getDefaultConf is used.
        """
        def end_getAllConf(self, _r):
            return _M_Murmur.Server._op_getAllConf.end(self, _r)

        """
        Set a configuration item.
        Arguments:
        key -- Configuration key.
        value -- Configuration value.
        context -- The request context for the invocation.
        """
        def setConf(self, key, value, context=None):
            return _M_Murmur.Server._op_setConf.invoke(self, ((key, value), context))

        """
        Set a configuration item.
        Arguments:
        key -- Configuration key.
        value -- Configuration value.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def setConfAsync(self, key, value, context=None):
            return _M_Murmur.Server._op_setConf.invokeAsync(self, ((key, value), context))

        """
        Set a configuration item.
        Arguments:
        key -- Configuration key.
        value -- Configuration value.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_setConf(self, key, value, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_setConf.begin(self, ((key, value), _response, _ex, _sent, context))

        """
        Set a configuration item.
        Arguments:
        key -- Configuration key.
        value -- Configuration value.
        """
        def end_setConf(self, _r):
            return _M_Murmur.Server._op_setConf.end(self, _r)

        """
        Set superuser password. This is just a convenience for using updateRegistration on user id 0.
        Arguments:
        pw -- Password.
        context -- The request context for the invocation.
        """
        def setSuperuserPassword(self, pw, context=None):
            return _M_Murmur.Server._op_setSuperuserPassword.invoke(self, ((pw, ), context))

        """
        Set superuser password. This is just a convenience for using updateRegistration on user id 0.
        Arguments:
        pw -- Password.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def setSuperuserPasswordAsync(self, pw, context=None):
            return _M_Murmur.Server._op_setSuperuserPassword.invokeAsync(self, ((pw, ), context))

        """
        Set superuser password. This is just a convenience for using updateRegistration on user id 0.
        Arguments:
        pw -- Password.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_setSuperuserPassword(self, pw, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_setSuperuserPassword.begin(self, ((pw, ), _response, _ex, _sent, context))

        """
        Set superuser password. This is just a convenience for using updateRegistration on user id 0.
        Arguments:
        pw -- Password.
        """
        def end_setSuperuserPassword(self, _r):
            return _M_Murmur.Server._op_setSuperuserPassword.end(self, _r)

        """
        Fetch log entries.
        Arguments:
        first -- Lowest numbered entry to fetch. 0 is the most recent item.
        last -- Last entry to fetch.
        context -- The request context for the invocation.
        Returns: List of log entries.
        """
        def getLog(self, first, last, context=None):
            return _M_Murmur.Server._op_getLog.invoke(self, ((first, last), context))

        """
        Fetch log entries.
        Arguments:
        first -- Lowest numbered entry to fetch. 0 is the most recent item.
        last -- Last entry to fetch.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getLogAsync(self, first, last, context=None):
            return _M_Murmur.Server._op_getLog.invokeAsync(self, ((first, last), context))

        """
        Fetch log entries.
        Arguments:
        first -- Lowest numbered entry to fetch. 0 is the most recent item.
        last -- Last entry to fetch.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getLog(self, first, last, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_getLog.begin(self, ((first, last), _response, _ex, _sent, context))

        """
        Fetch log entries.
        Arguments:
        first -- Lowest numbered entry to fetch. 0 is the most recent item.
        last -- Last entry to fetch.
        Returns: List of log entries.
        """
        def end_getLog(self, _r):
            return _M_Murmur.Server._op_getLog.end(self, _r)

        """
        Fetch length of log
        Arguments:
        context -- The request context for the invocation.
        Returns: Number of entries in log
        """
        def getLogLen(self, context=None):
            return _M_Murmur.Server._op_getLogLen.invoke(self, ((), context))

        """
        Fetch length of log
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getLogLenAsync(self, context=None):
            return _M_Murmur.Server._op_getLogLen.invokeAsync(self, ((), context))

        """
        Fetch length of log
        Arguments:
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getLogLen(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_getLogLen.begin(self, ((), _response, _ex, _sent, context))

        """
        Fetch length of log
        Arguments:
        Returns: Number of entries in log
        """
        def end_getLogLen(self, _r):
            return _M_Murmur.Server._op_getLogLen.end(self, _r)

        """
        Fetch all users. This returns all currently connected users on the server.
        Arguments:
        context -- The request context for the invocation.
        Returns: List of connected users.
        """
        def getUsers(self, context=None):
            return _M_Murmur.Server._op_getUsers.invoke(self, ((), context))

        """
        Fetch all users. This returns all currently connected users on the server.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getUsersAsync(self, context=None):
            return _M_Murmur.Server._op_getUsers.invokeAsync(self, ((), context))

        """
        Fetch all users. This returns all currently connected users on the server.
        Arguments:
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getUsers(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_getUsers.begin(self, ((), _response, _ex, _sent, context))

        """
        Fetch all users. This returns all currently connected users on the server.
        Arguments:
        Returns: List of connected users.
        """
        def end_getUsers(self, _r):
            return _M_Murmur.Server._op_getUsers.end(self, _r)

        """
        Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
        Arguments:
        context -- The request context for the invocation.
        Returns: List of defined channels.
        """
        def getChannels(self, context=None):
            return _M_Murmur.Server._op_getChannels.invoke(self, ((), context))

        """
        Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getChannelsAsync(self, context=None):
            return _M_Murmur.Server._op_getChannels.invokeAsync(self, ((), context))

        """
        Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
        Arguments:
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getChannels(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_getChannels.begin(self, ((), _response, _ex, _sent, context))

        """
        Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
        Arguments:
        Returns: List of defined channels.
        """
        def end_getChannels(self, _r):
            return _M_Murmur.Server._op_getChannels.end(self, _r)

        """
        Fetch certificate of user. This returns the complete certificate chain of a user.
        Arguments:
        session -- Connection ID of user. See User.session.
        context -- The request context for the invocation.
        Returns: Certificate list of user.
        """
        def getCertificateList(self, session, context=None):
            return _M_Murmur.Server._op_getCertificateList.invoke(self, ((session, ), context))

        """
        Fetch certificate of user. This returns the complete certificate chain of a user.
        Arguments:
        session -- Connection ID of user. See User.session.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getCertificateListAsync(self, session, context=None):
            return _M_Murmur.Server._op_getCertificateList.invokeAsync(self, ((session, ), context))

        """
        Fetch certificate of user. This returns the complete certificate chain of a user.
        Arguments:
        session -- Connection ID of user. See User.session.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getCertificateList(self, session, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_getCertificateList.begin(self, ((session, ), _response, _ex, _sent, context))

        """
        Fetch certificate of user. This returns the complete certificate chain of a user.
        Arguments:
        session -- Connection ID of user. See User.session.
        Returns: Certificate list of user.
        """
        def end_getCertificateList(self, _r):
            return _M_Murmur.Server._op_getCertificateList.end(self, _r)

        """
        Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
        as a tree. This is primarily used for viewing the state of the server on a webpage.
        Arguments:
        context -- The request context for the invocation.
        Returns: Recursive tree of all channels and connected users.
        """
        def getTree(self, context=None):
            return _M_Murmur.Server._op_getTree.invoke(self, ((), context))

        """
        Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
        as a tree. This is primarily used for viewing the state of the server on a webpage.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getTreeAsync(self, context=None):
            return _M_Murmur.Server._op_getTree.invokeAsync(self, ((), context))

        """
        Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
        as a tree. This is primarily used for viewing the state of the server on a webpage.
        Arguments:
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getTree(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_getTree.begin(self, ((), _response, _ex, _sent, context))

        """
        Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
        as a tree. This is primarily used for viewing the state of the server on a webpage.
        Arguments:
        Returns: Recursive tree of all channels and connected users.
        """
        def end_getTree(self, _r):
            return _M_Murmur.Server._op_getTree.end(self, _r)

        """
        Fetch all current IP bans on the server.
        Arguments:
        context -- The request context for the invocation.
        Returns: List of bans.
        """
        def getBans(self, context=None):
            return _M_Murmur.Server._op_getBans.invoke(self, ((), context))

        """
        Fetch all current IP bans on the server.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getBansAsync(self, context=None):
            return _M_Murmur.Server._op_getBans.invokeAsync(self, ((), context))

        """
        Fetch all current IP bans on the server.
        Arguments:
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getBans(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_getBans.begin(self, ((), _response, _ex, _sent, context))

        """
        Fetch all current IP bans on the server.
        Arguments:
        Returns: List of bans.
        """
        def end_getBans(self, _r):
            return _M_Murmur.Server._op_getBans.end(self, _r)

        """
        Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call getBans and then
        append to the returned list before calling this method.
        Arguments:
        bans -- List of bans.
        context -- The request context for the invocation.
        """
        def setBans(self, bans, context=None):
            return _M_Murmur.Server._op_setBans.invoke(self, ((bans, ), context))

        """
        Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call getBans and then
        append to the returned list before calling this method.
        Arguments:
        bans -- List of bans.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def setBansAsync(self, bans, context=None):
            return _M_Murmur.Server._op_setBans.invokeAsync(self, ((bans, ), context))

        """
        Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call getBans and then
        append to the returned list before calling this method.
        Arguments:
        bans -- List of bans.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_setBans(self, bans, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_setBans.begin(self, ((bans, ), _response, _ex, _sent, context))

        """
        Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call getBans and then
        append to the returned list before calling this method.
        Arguments:
        bans -- List of bans.
        """
        def end_setBans(self, _r):
            return _M_Murmur.Server._op_setBans.end(self, _r)

        """
        Kick a user. The user is not banned, and is free to rejoin the server.
        Arguments:
        session -- Connection ID of user. See User.session.
        reason -- Text message to show when user is kicked.
        context -- The request context for the invocation.
        """
        def kickUser(self, session, reason, context=None):
            return _M_Murmur.Server._op_kickUser.invoke(self, ((session, reason), context))

        """
        Kick a user. The user is not banned, and is free to rejoin the server.
        Arguments:
        session -- Connection ID of user. See User.session.
        reason -- Text message to show when user is kicked.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def kickUserAsync(self, session, reason, context=None):
            return _M_Murmur.Server._op_kickUser.invokeAsync(self, ((session, reason), context))

        """
        Kick a user. The user is not banned, and is free to rejoin the server.
        Arguments:
        session -- Connection ID of user. See User.session.
        reason -- Text message to show when user is kicked.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_kickUser(self, session, reason, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_kickUser.begin(self, ((session, reason), _response, _ex, _sent, context))

        """
        Kick a user. The user is not banned, and is free to rejoin the server.
        Arguments:
        session -- Connection ID of user. See User.session.
        reason -- Text message to show when user is kicked.
        """
        def end_kickUser(self, _r):
            return _M_Murmur.Server._op_kickUser.end(self, _r)

        """
        Get state of a single connected user.
        Arguments:
        session -- Connection ID of user. See User.session.
        context -- The request context for the invocation.
        Returns: State of connected user.
        """
        def getState(self, session, context=None):
            return _M_Murmur.Server._op_getState.invoke(self, ((session, ), context))

        """
        Get state of a single connected user.
        Arguments:
        session -- Connection ID of user. See User.session.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getStateAsync(self, session, context=None):
            return _M_Murmur.Server._op_getState.invokeAsync(self, ((session, ), context))

        """
        Get state of a single connected user.
        Arguments:
        session -- Connection ID of user. See User.session.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getState(self, session, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_getState.begin(self, ((session, ), _response, _ex, _sent, context))

        """
        Get state of a single connected user.
        Arguments:
        session -- Connection ID of user. See User.session.
        Returns: State of connected user.
        """
        def end_getState(self, _r):
            return _M_Murmur.Server._op_getState.end(self, _r)

        """
        Set user state. You can use this to move, mute and deafen users.
        Arguments:
        state -- User state to set.
        context -- The request context for the invocation.
        """
        def setState(self, state, context=None):
            return _M_Murmur.Server._op_setState.invoke(self, ((state, ), context))

        """
        Set user state. You can use this to move, mute and deafen users.
        Arguments:
        state -- User state to set.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def setStateAsync(self, state, context=None):
            return _M_Murmur.Server._op_setState.invokeAsync(self, ((state, ), context))

        """
        Set user state. You can use this to move, mute and deafen users.
        Arguments:
        state -- User state to set.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_setState(self, state, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_setState.begin(self, ((state, ), _response, _ex, _sent, context))

        """
        Set user state. You can use this to move, mute and deafen users.
        Arguments:
        state -- User state to set.
        """
        def end_setState(self, _r):
            return _M_Murmur.Server._op_setState.end(self, _r)

        """
        Send text message to a single user.
        Arguments:
        session -- Connection ID of user. See User.session.
        text -- Message to send.
        context -- The request context for the invocation.
        """
        def sendMessage(self, session, text, context=None):
            return _M_Murmur.Server._op_sendMessage.invoke(self, ((session, text), context))

        """
        Send text message to a single user.
        Arguments:
        session -- Connection ID of user. See User.session.
        text -- Message to send.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def sendMessageAsync(self, session, text, context=None):
            return _M_Murmur.Server._op_sendMessage.invokeAsync(self, ((session, text), context))

        """
        Send text message to a single user.
        Arguments:
        session -- Connection ID of user. See User.session.
        text -- Message to send.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_sendMessage(self, session, text, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_sendMessage.begin(self, ((session, text), _response, _ex, _sent, context))

        """
        Send text message to a single user.
        Arguments:
        session -- Connection ID of user. See User.session.
        text -- Message to send.
        """
        def end_sendMessage(self, _r):
            return _M_Murmur.Server._op_sendMessage.end(self, _r)

        """
        Check if user is permitted to perform action.
        Arguments:
        session -- Connection ID of user. See User.session.
        channelid -- ID of Channel. See Channel.id.
        perm -- Permission bits to check.
        context -- The request context for the invocation.
        Returns: true if any of the permissions in perm were set for the user.
        """
        def hasPermission(self, session, channelid, perm, context=None):
            return _M_Murmur.Server._op_hasPermission.invoke(self, ((session, channelid, perm), context))

        """
        Check if user is permitted to perform action.
        Arguments:
        session -- Connection ID of user. See User.session.
        channelid -- ID of Channel. See Channel.id.
        perm -- Permission bits to check.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def hasPermissionAsync(self, session, channelid, perm, context=None):
            return _M_Murmur.Server._op_hasPermission.invokeAsync(self, ((session, channelid, perm), context))

        """
        Check if user is permitted to perform action.
        Arguments:
        session -- Connection ID of user. See User.session.
        channelid -- ID of Channel. See Channel.id.
        perm -- Permission bits to check.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_hasPermission(self, session, channelid, perm, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_hasPermission.begin(self, ((session, channelid, perm), _response, _ex, _sent, context))

        """
        Check if user is permitted to perform action.
        Arguments:
        session -- Connection ID of user. See User.session.
        channelid -- ID of Channel. See Channel.id.
        perm -- Permission bits to check.
        Returns: true if any of the permissions in perm were set for the user.
        """
        def end_hasPermission(self, _r):
            return _M_Murmur.Server._op_hasPermission.end(self, _r)

        """
        Return users effective permissions
        Arguments:
        session -- Connection ID of user. See User.session.
        channelid -- ID of Channel. See Channel.id.
        context -- The request context for the invocation.
        Returns: bitfield of allowed actions
        """
        def effectivePermissions(self, session, channelid, context=None):
            return _M_Murmur.Server._op_effectivePermissions.invoke(self, ((session, channelid), context))

        """
        Return users effective permissions
        Arguments:
        session -- Connection ID of user. See User.session.
        channelid -- ID of Channel. See Channel.id.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def effectivePermissionsAsync(self, session, channelid, context=None):
            return _M_Murmur.Server._op_effectivePermissions.invokeAsync(self, ((session, channelid), context))

        """
        Return users effective permissions
        Arguments:
        session -- Connection ID of user. See User.session.
        channelid -- ID of Channel. See Channel.id.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_effectivePermissions(self, session, channelid, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_effectivePermissions.begin(self, ((session, channelid), _response, _ex, _sent, context))

        """
        Return users effective permissions
        Arguments:
        session -- Connection ID of user. See User.session.
        channelid -- ID of Channel. See Channel.id.
        Returns: bitfield of allowed actions
        """
        def end_effectivePermissions(self, _r):
            return _M_Murmur.Server._op_effectivePermissions.end(self, _r)

        """
        Add a context callback. This is done per user, and will add a context menu action for the user.
        Arguments:
        session -- Session of user which should receive context entry.
        action -- Action string, a unique name to associate with the action.
        text -- Name of action shown to user.
        cb -- Callback interface which will receive notifications.
        ctx -- Context this should be used in. Needs to be one or a combination of ContextServer, ContextChannel and ContextUser.
        context -- The request context for the invocation.
        """
        def addContextCallback(self, session, action, text, cb, ctx, context=None):
            return _M_Murmur.Server._op_addContextCallback.invoke(self, ((session, action, text, cb, ctx), context))

        """
        Add a context callback. This is done per user, and will add a context menu action for the user.
        Arguments:
        session -- Session of user which should receive context entry.
        action -- Action string, a unique name to associate with the action.
        text -- Name of action shown to user.
        cb -- Callback interface which will receive notifications.
        ctx -- Context this should be used in. Needs to be one or a combination of ContextServer, ContextChannel and ContextUser.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def addContextCallbackAsync(self, session, action, text, cb, ctx, context=None):
            return _M_Murmur.Server._op_addContextCallback.invokeAsync(self, ((session, action, text, cb, ctx), context))

        """
        Add a context callback. This is done per user, and will add a context menu action for the user.
        Arguments:
        session -- Session of user which should receive context entry.
        action -- Action string, a unique name to associate with the action.
        text -- Name of action shown to user.
        cb -- Callback interface which will receive notifications.
        ctx -- Context this should be used in. Needs to be one or a combination of ContextServer, ContextChannel and ContextUser.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_addContextCallback(self, session, action, text, cb, ctx, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_addContextCallback.begin(self, ((session, action, text, cb, ctx), _response, _ex, _sent, context))

        """
        Add a context callback. This is done per user, and will add a context menu action for the user.
        Arguments:
        session -- Session of user which should receive context entry.
        action -- Action string, a unique name to associate with the action.
        text -- Name of action shown to user.
        cb -- Callback interface which will receive notifications.
        ctx -- Context this should be used in. Needs to be one or a combination of ContextServer, ContextChannel and ContextUser.
        """
        def end_addContextCallback(self, _r):
            return _M_Murmur.Server._op_addContextCallback.end(self, _r)

        """
        Remove a callback.
        Arguments:
        cb -- Callback interface to be removed. This callback will be removed from all from all users.
        context -- The request context for the invocation.
        """
        def removeContextCallback(self, cb, context=None):
            return _M_Murmur.Server._op_removeContextCallback.invoke(self, ((cb, ), context))

        """
        Remove a callback.
        Arguments:
        cb -- Callback interface to be removed. This callback will be removed from all from all users.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def removeContextCallbackAsync(self, cb, context=None):
            return _M_Murmur.Server._op_removeContextCallback.invokeAsync(self, ((cb, ), context))

        """
        Remove a callback.
        Arguments:
        cb -- Callback interface to be removed. This callback will be removed from all from all users.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_removeContextCallback(self, cb, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_removeContextCallback.begin(self, ((cb, ), _response, _ex, _sent, context))

        """
        Remove a callback.
        Arguments:
        cb -- Callback interface to be removed. This callback will be removed from all from all users.
        """
        def end_removeContextCallback(self, _r):
            return _M_Murmur.Server._op_removeContextCallback.end(self, _r)

        """
        Get state of single channel.
        Arguments:
        channelid -- ID of Channel. See Channel.id.
        context -- The request context for the invocation.
        Returns: State of channel.
        """
        def getChannelState(self, channelid, context=None):
            return _M_Murmur.Server._op_getChannelState.invoke(self, ((channelid, ), context))

        """
        Get state of single channel.
        Arguments:
        channelid -- ID of Channel. See Channel.id.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getChannelStateAsync(self, channelid, context=None):
            return _M_Murmur.Server._op_getChannelState.invokeAsync(self, ((channelid, ), context))

        """
        Get state of single channel.
        Arguments:
        channelid -- ID of Channel. See Channel.id.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getChannelState(self, channelid, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_getChannelState.begin(self, ((channelid, ), _response, _ex, _sent, context))

        """
        Get state of single channel.
        Arguments:
        channelid -- ID of Channel. See Channel.id.
        Returns: State of channel.
        """
        def end_getChannelState(self, _r):
            return _M_Murmur.Server._op_getChannelState.end(self, _r)

        """
        Set state of a single channel. You can use this to move or relink channels.
        Arguments:
        state -- Channel state to set.
        context -- The request context for the invocation.
        """
        def setChannelState(self, state, context=None):
            return _M_Murmur.Server._op_setChannelState.invoke(self, ((state, ), context))

        """
        Set state of a single channel. You can use this to move or relink channels.
        Arguments:
        state -- Channel state to set.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def setChannelStateAsync(self, state, context=None):
            return _M_Murmur.Server._op_setChannelState.invokeAsync(self, ((state, ), context))

        """
        Set state of a single channel. You can use this to move or relink channels.
        Arguments:
        state -- Channel state to set.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_setChannelState(self, state, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_setChannelState.begin(self, ((state, ), _response, _ex, _sent, context))

        """
        Set state of a single channel. You can use this to move or relink channels.
        Arguments:
        state -- Channel state to set.
        """
        def end_setChannelState(self, _r):
            return _M_Murmur.Server._op_setChannelState.end(self, _r)

        """
        Remove a channel and all its subchannels.
        Arguments:
        channelid -- ID of Channel. See Channel.id.
        context -- The request context for the invocation.
        """
        def removeChannel(self, channelid, context=None):
            return _M_Murmur.Server._op_removeChannel.invoke(self, ((channelid, ), context))

        """
        Remove a channel and all its subchannels.
        Arguments:
        channelid -- ID of Channel. See Channel.id.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def removeChannelAsync(self, channelid, context=None):
            return _M_Murmur.Server._op_removeChannel.invokeAsync(self, ((channelid, ), context))

        """
        Remove a channel and all its subchannels.
        Arguments:
        channelid -- ID of Channel. See Channel.id.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_removeChannel(self, channelid, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_removeChannel.begin(self, ((channelid, ), _response, _ex, _sent, context))

        """
        Remove a channel and all its subchannels.
        Arguments:
        channelid -- ID of Channel. See Channel.id.
        """
        def end_removeChannel(self, _r):
            return _M_Murmur.Server._op_removeChannel.end(self, _r)

        """
        Add a new channel.
        Arguments:
        name -- Name of new channel.
        parent -- Channel ID of parent channel. See Channel.id.
        context -- The request context for the invocation.
        Returns: ID of newly created channel.
        """
        def addChannel(self, name, parent, context=None):
            return _M_Murmur.Server._op_addChannel.invoke(self, ((name, parent), context))

        """
        Add a new channel.
        Arguments:
        name -- Name of new channel.
        parent -- Channel ID of parent channel. See Channel.id.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def addChannelAsync(self, name, parent, context=None):
            return _M_Murmur.Server._op_addChannel.invokeAsync(self, ((name, parent), context))

        """
        Add a new channel.
        Arguments:
        name -- Name of new channel.
        parent -- Channel ID of parent channel. See Channel.id.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_addChannel(self, name, parent, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_addChannel.begin(self, ((name, parent), _response, _ex, _sent, context))

        """
        Add a new channel.
        Arguments:
        name -- Name of new channel.
        parent -- Channel ID of parent channel. See Channel.id.
        Returns: ID of newly created channel.
        """
        def end_addChannel(self, _r):
            return _M_Murmur.Server._op_addChannel.end(self, _r)

        """
        Send text message to channel or a tree of channels.
        Arguments:
        channelid -- Channel ID of channel to send to. See Channel.id.
        tree -- If true, the message will be sent to the channel and all its subchannels.
        text -- Message to send.
        context -- The request context for the invocation.
        """
        def sendMessageChannel(self, channelid, tree, text, context=None):
            return _M_Murmur.Server._op_sendMessageChannel.invoke(self, ((channelid, tree, text), context))

        """
        Send text message to channel or a tree of channels.
        Arguments:
        channelid -- Channel ID of channel to send to. See Channel.id.
        tree -- If true, the message will be sent to the channel and all its subchannels.
        text -- Message to send.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def sendMessageChannelAsync(self, channelid, tree, text, context=None):
            return _M_Murmur.Server._op_sendMessageChannel.invokeAsync(self, ((channelid, tree, text), context))

        """
        Send text message to channel or a tree of channels.
        Arguments:
        channelid -- Channel ID of channel to send to. See Channel.id.
        tree -- If true, the message will be sent to the channel and all its subchannels.
        text -- Message to send.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_sendMessageChannel(self, channelid, tree, text, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_sendMessageChannel.begin(self, ((channelid, tree, text), _response, _ex, _sent, context))

        """
        Send text message to channel or a tree of channels.
        Arguments:
        channelid -- Channel ID of channel to send to. See Channel.id.
        tree -- If true, the message will be sent to the channel and all its subchannels.
        text -- Message to send.
        """
        def end_sendMessageChannel(self, _r):
            return _M_Murmur.Server._op_sendMessageChannel.end(self, _r)

        """
        Retrieve ACLs and Groups on a channel.
        Arguments:
        channelid -- Channel ID of channel to fetch from. See Channel.id.
        context -- The request context for the invocation.
        Returns a tuple containing the following:
        acls -- List of ACLs on the channel. This will include inherited ACLs.
        groups -- List of groups on the channel. This will include inherited groups.
        inherit -- Does this channel inherit ACLs from the parent channel?
        """
        def getACL(self, channelid, context=None):
            return _M_Murmur.Server._op_getACL.invoke(self, ((channelid, ), context))

        """
        Retrieve ACLs and Groups on a channel.
        Arguments:
        channelid -- Channel ID of channel to fetch from. See Channel.id.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getACLAsync(self, channelid, context=None):
            return _M_Murmur.Server._op_getACL.invokeAsync(self, ((channelid, ), context))

        """
        Retrieve ACLs and Groups on a channel.
        Arguments:
        channelid -- Channel ID of channel to fetch from. See Channel.id.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getACL(self, channelid, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_getACL.begin(self, ((channelid, ), _response, _ex, _sent, context))

        """
        Retrieve ACLs and Groups on a channel.
        Arguments:
        channelid -- Channel ID of channel to fetch from. See Channel.id.
        Returns a tuple containing the following:
        acls -- List of ACLs on the channel. This will include inherited ACLs.
        groups -- List of groups on the channel. This will include inherited groups.
        inherit -- Does this channel inherit ACLs from the parent channel?
        """
        def end_getACL(self, _r):
            return _M_Murmur.Server._op_getACL.end(self, _r)

        """
        Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
        Arguments:
        channelid -- Channel ID of channel to fetch from. See Channel.id.
        acls -- List of ACLs on the channel.
        groups -- List of groups on the channel.
        inherit -- Should this channel inherit ACLs from the parent channel?
        context -- The request context for the invocation.
        """
        def setACL(self, channelid, acls, groups, inherit, context=None):
            return _M_Murmur.Server._op_setACL.invoke(self, ((channelid, acls, groups, inherit), context))

        """
        Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
        Arguments:
        channelid -- Channel ID of channel to fetch from. See Channel.id.
        acls -- List of ACLs on the channel.
        groups -- List of groups on the channel.
        inherit -- Should this channel inherit ACLs from the parent channel?
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def setACLAsync(self, channelid, acls, groups, inherit, context=None):
            return _M_Murmur.Server._op_setACL.invokeAsync(self, ((channelid, acls, groups, inherit), context))

        """
        Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
        Arguments:
        channelid -- Channel ID of channel to fetch from. See Channel.id.
        acls -- List of ACLs on the channel.
        groups -- List of groups on the channel.
        inherit -- Should this channel inherit ACLs from the parent channel?
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_setACL(self, channelid, acls, groups, inherit, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_setACL.begin(self, ((channelid, acls, groups, inherit), _response, _ex, _sent, context))

        """
        Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
        Arguments:
        channelid -- Channel ID of channel to fetch from. See Channel.id.
        acls -- List of ACLs on the channel.
        groups -- List of groups on the channel.
        inherit -- Should this channel inherit ACLs from the parent channel?
        """
        def end_setACL(self, _r):
            return _M_Murmur.Server._op_setACL.end(self, _r)

        """
        Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
        Arguments:
        channelid -- Channel ID of channel to add to. See Channel.id.
        session -- Connection ID of user. See User.session.
        group -- Group name to add to.
        context -- The request context for the invocation.
        """
        def addUserToGroup(self, channelid, session, group, context=None):
            return _M_Murmur.Server._op_addUserToGroup.invoke(self, ((channelid, session, group), context))

        """
        Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
        Arguments:
        channelid -- Channel ID of channel to add to. See Channel.id.
        session -- Connection ID of user. See User.session.
        group -- Group name to add to.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def addUserToGroupAsync(self, channelid, session, group, context=None):
            return _M_Murmur.Server._op_addUserToGroup.invokeAsync(self, ((channelid, session, group), context))

        """
        Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
        Arguments:
        channelid -- Channel ID of channel to add to. See Channel.id.
        session -- Connection ID of user. See User.session.
        group -- Group name to add to.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_addUserToGroup(self, channelid, session, group, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_addUserToGroup.begin(self, ((channelid, session, group), _response, _ex, _sent, context))

        """
        Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
        Arguments:
        channelid -- Channel ID of channel to add to. See Channel.id.
        session -- Connection ID of user. See User.session.
        group -- Group name to add to.
        """
        def end_addUserToGroup(self, _r):
            return _M_Murmur.Server._op_addUserToGroup.end(self, _r)

        """
        Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
        Arguments:
        channelid -- Channel ID of channel to add to. See Channel.id.
        session -- Connection ID of user. See User.session.
        group -- Group name to remove from.
        context -- The request context for the invocation.
        """
        def removeUserFromGroup(self, channelid, session, group, context=None):
            return _M_Murmur.Server._op_removeUserFromGroup.invoke(self, ((channelid, session, group), context))

        """
        Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
        Arguments:
        channelid -- Channel ID of channel to add to. See Channel.id.
        session -- Connection ID of user. See User.session.
        group -- Group name to remove from.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def removeUserFromGroupAsync(self, channelid, session, group, context=None):
            return _M_Murmur.Server._op_removeUserFromGroup.invokeAsync(self, ((channelid, session, group), context))

        """
        Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
        Arguments:
        channelid -- Channel ID of channel to add to. See Channel.id.
        session -- Connection ID of user. See User.session.
        group -- Group name to remove from.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_removeUserFromGroup(self, channelid, session, group, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_removeUserFromGroup.begin(self, ((channelid, session, group), _response, _ex, _sent, context))

        """
        Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
        Arguments:
        channelid -- Channel ID of channel to add to. See Channel.id.
        session -- Connection ID of user. See User.session.
        group -- Group name to remove from.
        """
        def end_removeUserFromGroup(self, _r):
            return _M_Murmur.Server._op_removeUserFromGroup.end(self, _r)

        """
        Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
        To remove a redirect pass an empty target string. This is intended for context groups.
        Arguments:
        session -- Connection ID of user. See User.session.
        source -- Group name to redirect from.
        target -- Group name to redirect to.
        context -- The request context for the invocation.
        """
        def redirectWhisperGroup(self, session, source, target, context=None):
            return _M_Murmur.Server._op_redirectWhisperGroup.invoke(self, ((session, source, target), context))

        """
        Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
        To remove a redirect pass an empty target string. This is intended for context groups.
        Arguments:
        session -- Connection ID of user. See User.session.
        source -- Group name to redirect from.
        target -- Group name to redirect to.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def redirectWhisperGroupAsync(self, session, source, target, context=None):
            return _M_Murmur.Server._op_redirectWhisperGroup.invokeAsync(self, ((session, source, target), context))

        """
        Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
        To remove a redirect pass an empty target string. This is intended for context groups.
        Arguments:
        session -- Connection ID of user. See User.session.
        source -- Group name to redirect from.
        target -- Group name to redirect to.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_redirectWhisperGroup(self, session, source, target, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_redirectWhisperGroup.begin(self, ((session, source, target), _response, _ex, _sent, context))

        """
        Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
        To remove a redirect pass an empty target string. This is intended for context groups.
        Arguments:
        session -- Connection ID of user. See User.session.
        source -- Group name to redirect from.
        target -- Group name to redirect to.
        """
        def end_redirectWhisperGroup(self, _r):
            return _M_Murmur.Server._op_redirectWhisperGroup.end(self, _r)

        """
        Map a list of User.userid to a matching name.
        Arguments:
        ids -- 
        context -- The request context for the invocation.
        Returns: Matching list of names, with an empty string representing invalid or unknown ids.
        """
        def getUserNames(self, ids, context=None):
            return _M_Murmur.Server._op_getUserNames.invoke(self, ((ids, ), context))

        """
        Map a list of User.userid to a matching name.
        Arguments:
        ids -- 
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getUserNamesAsync(self, ids, context=None):
            return _M_Murmur.Server._op_getUserNames.invokeAsync(self, ((ids, ), context))

        """
        Map a list of User.userid to a matching name.
        Arguments:
        ids -- 
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getUserNames(self, ids, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_getUserNames.begin(self, ((ids, ), _response, _ex, _sent, context))

        """
        Map a list of User.userid to a matching name.
        Arguments:
        ids -- 
        Returns: Matching list of names, with an empty string representing invalid or unknown ids.
        """
        def end_getUserNames(self, _r):
            return _M_Murmur.Server._op_getUserNames.end(self, _r)

        """
        Map a list of user names to a matching id.
        @reuturn List of matching ids, with -1 representing invalid or unknown user names.
        Arguments:
        names -- 
        context -- The request context for the invocation.
        """
        def getUserIds(self, names, context=None):
            return _M_Murmur.Server._op_getUserIds.invoke(self, ((names, ), context))

        """
        Map a list of user names to a matching id.
        @reuturn List of matching ids, with -1 representing invalid or unknown user names.
        Arguments:
        names -- 
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getUserIdsAsync(self, names, context=None):
            return _M_Murmur.Server._op_getUserIds.invokeAsync(self, ((names, ), context))

        """
        Map a list of user names to a matching id.
        @reuturn List of matching ids, with -1 representing invalid or unknown user names.
        Arguments:
        names -- 
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getUserIds(self, names, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_getUserIds.begin(self, ((names, ), _response, _ex, _sent, context))

        """
        Map a list of user names to a matching id.
        @reuturn List of matching ids, with -1 representing invalid or unknown user names.
        Arguments:
        names -- 
        """
        def end_getUserIds(self, _r):
            return _M_Murmur.Server._op_getUserIds.end(self, _r)

        """
        Register a new user.
        Arguments:
        info -- Information about new user. Must include at least "name".
        context -- The request context for the invocation.
        Returns: The ID of the user. See RegisteredUser.userid.
        """
        def registerUser(self, info, context=None):
            return _M_Murmur.Server._op_registerUser.invoke(self, ((info, ), context))

        """
        Register a new user.
        Arguments:
        info -- Information about new user. Must include at least "name".
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def registerUserAsync(self, info, context=None):
            return _M_Murmur.Server._op_registerUser.invokeAsync(self, ((info, ), context))

        """
        Register a new user.
        Arguments:
        info -- Information about new user. Must include at least "name".
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_registerUser(self, info, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_registerUser.begin(self, ((info, ), _response, _ex, _sent, context))

        """
        Register a new user.
        Arguments:
        info -- Information about new user. Must include at least "name".
        Returns: The ID of the user. See RegisteredUser.userid.
        """
        def end_registerUser(self, _r):
            return _M_Murmur.Server._op_registerUser.end(self, _r)

        """
        Remove a user registration.
        Arguments:
        userid -- ID of registered user. See RegisteredUser.userid.
        context -- The request context for the invocation.
        """
        def unregisterUser(self, userid, context=None):
            return _M_Murmur.Server._op_unregisterUser.invoke(self, ((userid, ), context))

        """
        Remove a user registration.
        Arguments:
        userid -- ID of registered user. See RegisteredUser.userid.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def unregisterUserAsync(self, userid, context=None):
            return _M_Murmur.Server._op_unregisterUser.invokeAsync(self, ((userid, ), context))

        """
        Remove a user registration.
        Arguments:
        userid -- ID of registered user. See RegisteredUser.userid.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_unregisterUser(self, userid, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_unregisterUser.begin(self, ((userid, ), _response, _ex, _sent, context))

        """
        Remove a user registration.
        Arguments:
        userid -- ID of registered user. See RegisteredUser.userid.
        """
        def end_unregisterUser(self, _r):
            return _M_Murmur.Server._op_unregisterUser.end(self, _r)

        """
        Update the registration for a user. You can use this to set the email or password of a user,
        and can also use it to change the user's name.
        Arguments:
        userid -- 
        info -- 
        context -- The request context for the invocation.
        """
        def updateRegistration(self, userid, info, context=None):
            return _M_Murmur.Server._op_updateRegistration.invoke(self, ((userid, info), context))

        """
        Update the registration for a user. You can use this to set the email or password of a user,
        and can also use it to change the user's name.
        Arguments:
        userid -- 
        info -- 
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def updateRegistrationAsync(self, userid, info, context=None):
            return _M_Murmur.Server._op_updateRegistration.invokeAsync(self, ((userid, info), context))

        """
        Update the registration for a user. You can use this to set the email or password of a user,
        and can also use it to change the user's name.
        Arguments:
        userid -- 
        info -- 
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_updateRegistration(self, userid, info, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_updateRegistration.begin(self, ((userid, info), _response, _ex, _sent, context))

        """
        Update the registration for a user. You can use this to set the email or password of a user,
        and can also use it to change the user's name.
        Arguments:
        userid -- 
        info -- 
        """
        def end_updateRegistration(self, _r):
            return _M_Murmur.Server._op_updateRegistration.end(self, _r)

        """
        Fetch registration for a single user.
        Arguments:
        userid -- ID of registered user. See RegisteredUser.userid.
        context -- The request context for the invocation.
        Returns: Registration record.
        """
        def getRegistration(self, userid, context=None):
            return _M_Murmur.Server._op_getRegistration.invoke(self, ((userid, ), context))

        """
        Fetch registration for a single user.
        Arguments:
        userid -- ID of registered user. See RegisteredUser.userid.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getRegistrationAsync(self, userid, context=None):
            return _M_Murmur.Server._op_getRegistration.invokeAsync(self, ((userid, ), context))

        """
        Fetch registration for a single user.
        Arguments:
        userid -- ID of registered user. See RegisteredUser.userid.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getRegistration(self, userid, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_getRegistration.begin(self, ((userid, ), _response, _ex, _sent, context))

        """
        Fetch registration for a single user.
        Arguments:
        userid -- ID of registered user. See RegisteredUser.userid.
        Returns: Registration record.
        """
        def end_getRegistration(self, _r):
            return _M_Murmur.Server._op_getRegistration.end(self, _r)

        """
        Fetch a group of registered users.
        Arguments:
        filter -- Substring of user name. If blank, will retrieve all registered users.
        context -- The request context for the invocation.
        Returns: List of registration records.
        """
        def getRegisteredUsers(self, filter, context=None):
            return _M_Murmur.Server._op_getRegisteredUsers.invoke(self, ((filter, ), context))

        """
        Fetch a group of registered users.
        Arguments:
        filter -- Substring of user name. If blank, will retrieve all registered users.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getRegisteredUsersAsync(self, filter, context=None):
            return _M_Murmur.Server._op_getRegisteredUsers.invokeAsync(self, ((filter, ), context))

        """
        Fetch a group of registered users.
        Arguments:
        filter -- Substring of user name. If blank, will retrieve all registered users.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getRegisteredUsers(self, filter, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_getRegisteredUsers.begin(self, ((filter, ), _response, _ex, _sent, context))

        """
        Fetch a group of registered users.
        Arguments:
        filter -- Substring of user name. If blank, will retrieve all registered users.
        Returns: List of registration records.
        """
        def end_getRegisteredUsers(self, _r):
            return _M_Murmur.Server._op_getRegisteredUsers.end(self, _r)

        """
        Verify the password of a user. You can use this to verify a user's credentials.
        Arguments:
        name -- User name. See RegisteredUser.name.
        pw -- User password.
        context -- The request context for the invocation.
        Returns: User ID of registered user (See RegisteredUser.userid), -1 for failed authentication or -2 for unknown usernames.
        """
        def verifyPassword(self, name, pw, context=None):
            return _M_Murmur.Server._op_verifyPassword.invoke(self, ((name, pw), context))

        """
        Verify the password of a user. You can use this to verify a user's credentials.
        Arguments:
        name -- User name. See RegisteredUser.name.
        pw -- User password.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def verifyPasswordAsync(self, name, pw, context=None):
            return _M_Murmur.Server._op_verifyPassword.invokeAsync(self, ((name, pw), context))

        """
        Verify the password of a user. You can use this to verify a user's credentials.
        Arguments:
        name -- User name. See RegisteredUser.name.
        pw -- User password.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_verifyPassword(self, name, pw, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_verifyPassword.begin(self, ((name, pw), _response, _ex, _sent, context))

        """
        Verify the password of a user. You can use this to verify a user's credentials.
        Arguments:
        name -- User name. See RegisteredUser.name.
        pw -- User password.
        Returns: User ID of registered user (See RegisteredUser.userid), -1 for failed authentication or -2 for unknown usernames.
        """
        def end_verifyPassword(self, _r):
            return _M_Murmur.Server._op_verifyPassword.end(self, _r)

        """
        Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
        Arguments:
        userid -- ID of registered user. See RegisteredUser.userid.
        context -- The request context for the invocation.
        Returns: Custom texture associated with user or an empty texture.
        """
        def getTexture(self, userid, context=None):
            return _M_Murmur.Server._op_getTexture.invoke(self, ((userid, ), context))

        """
        Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
        Arguments:
        userid -- ID of registered user. See RegisteredUser.userid.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getTextureAsync(self, userid, context=None):
            return _M_Murmur.Server._op_getTexture.invokeAsync(self, ((userid, ), context))

        """
        Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
        Arguments:
        userid -- ID of registered user. See RegisteredUser.userid.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getTexture(self, userid, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_getTexture.begin(self, ((userid, ), _response, _ex, _sent, context))

        """
        Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
        Arguments:
        userid -- ID of registered user. See RegisteredUser.userid.
        Returns: Custom texture associated with user or an empty texture.
        """
        def end_getTexture(self, _r):
            return _M_Murmur.Server._op_getTexture.end(self, _r)

        """
        Set a user texture (now called avatar).
        Arguments:
        userid -- ID of registered user. See RegisteredUser.userid.
        tex -- Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.
        context -- The request context for the invocation.
        """
        def setTexture(self, userid, tex, context=None):
            return _M_Murmur.Server._op_setTexture.invoke(self, ((userid, tex), context))

        """
        Set a user texture (now called avatar).
        Arguments:
        userid -- ID of registered user. See RegisteredUser.userid.
        tex -- Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def setTextureAsync(self, userid, tex, context=None):
            return _M_Murmur.Server._op_setTexture.invokeAsync(self, ((userid, tex), context))

        """
        Set a user texture (now called avatar).
        Arguments:
        userid -- ID of registered user. See RegisteredUser.userid.
        tex -- Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_setTexture(self, userid, tex, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_setTexture.begin(self, ((userid, tex), _response, _ex, _sent, context))

        """
        Set a user texture (now called avatar).
        Arguments:
        userid -- ID of registered user. See RegisteredUser.userid.
        tex -- Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.
        """
        def end_setTexture(self, _r):
            return _M_Murmur.Server._op_setTexture.end(self, _r)

        """
        Get virtual server uptime.
        Arguments:
        context -- The request context for the invocation.
        Returns: Uptime of the virtual server in seconds
        """
        def getUptime(self, context=None):
            return _M_Murmur.Server._op_getUptime.invoke(self, ((), context))

        """
        Get virtual server uptime.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getUptimeAsync(self, context=None):
            return _M_Murmur.Server._op_getUptime.invokeAsync(self, ((), context))

        """
        Get virtual server uptime.
        Arguments:
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getUptime(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_getUptime.begin(self, ((), _response, _ex, _sent, context))

        """
        Get virtual server uptime.
        Arguments:
        Returns: Uptime of the virtual server in seconds
        """
        def end_getUptime(self, _r):
            return _M_Murmur.Server._op_getUptime.end(self, _r)

        """
        Update the server's certificate information.
        Reconfigure the running server's TLS socket with the given
        certificate and private key.
        The certificate and and private key must be PEM formatted.
        New clients will see the new certificate.
        Existing clients will continue to see the certificate the server
        was using when they connected to it.
        This method throws InvalidInputDataException if any of the
        following errors happen:
        - Unable to decode the PEM certificate and/or private key.
        - Unable to decrypt the private key with the given passphrase.
        - The certificate and/or private key do not contain RSA keys.
        - The certificate is not usable with the given private key.
        Arguments:
        certificate -- 
        privateKey -- 
        passphrase -- 
        context -- The request context for the invocation.
        """
        def updateCertificate(self, certificate, privateKey, passphrase, context=None):
            return _M_Murmur.Server._op_updateCertificate.invoke(self, ((certificate, privateKey, passphrase), context))

        """
        Update the server's certificate information.
        Reconfigure the running server's TLS socket with the given
        certificate and private key.
        The certificate and and private key must be PEM formatted.
        New clients will see the new certificate.
        Existing clients will continue to see the certificate the server
        was using when they connected to it.
        This method throws InvalidInputDataException if any of the
        following errors happen:
        - Unable to decode the PEM certificate and/or private key.
        - Unable to decrypt the private key with the given passphrase.
        - The certificate and/or private key do not contain RSA keys.
        - The certificate is not usable with the given private key.
        Arguments:
        certificate -- 
        privateKey -- 
        passphrase -- 
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def updateCertificateAsync(self, certificate, privateKey, passphrase, context=None):
            return _M_Murmur.Server._op_updateCertificate.invokeAsync(self, ((certificate, privateKey, passphrase), context))

        """
        Update the server's certificate information.
        Reconfigure the running server's TLS socket with the given
        certificate and private key.
        The certificate and and private key must be PEM formatted.
        New clients will see the new certificate.
        Existing clients will continue to see the certificate the server
        was using when they connected to it.
        This method throws InvalidInputDataException if any of the
        following errors happen:
        - Unable to decode the PEM certificate and/or private key.
        - Unable to decrypt the private key with the given passphrase.
        - The certificate and/or private key do not contain RSA keys.
        - The certificate is not usable with the given private key.
        Arguments:
        certificate -- 
        privateKey -- 
        passphrase -- 
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_updateCertificate(self, certificate, privateKey, passphrase, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_updateCertificate.begin(self, ((certificate, privateKey, passphrase), _response, _ex, _sent, context))

        """
        Update the server's certificate information.
        Reconfigure the running server's TLS socket with the given
        certificate and private key.
        The certificate and and private key must be PEM formatted.
        New clients will see the new certificate.
        Existing clients will continue to see the certificate the server
        was using when they connected to it.
        This method throws InvalidInputDataException if any of the
        following errors happen:
        - Unable to decode the PEM certificate and/or private key.
        - Unable to decrypt the private key with the given passphrase.
        - The certificate and/or private key do not contain RSA keys.
        - The certificate is not usable with the given private key.
        Arguments:
        certificate -- 
        privateKey -- 
        passphrase -- 
        """
        def end_updateCertificate(self, _r):
            return _M_Murmur.Server._op_updateCertificate.end(self, _r)

        """
        Makes the given user start listening to the given channel.
        Arguments:
        userid -- The ID of the user
        channelid -- The ID of the channel
        context -- The request context for the invocation.
        """
        def startListening(self, userid, channelid, context=None):
            return _M_Murmur.Server._op_startListening.invoke(self, ((userid, channelid), context))

        """
        Makes the given user start listening to the given channel.
        Arguments:
        userid -- The ID of the user
        channelid -- The ID of the channel
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def startListeningAsync(self, userid, channelid, context=None):
            return _M_Murmur.Server._op_startListening.invokeAsync(self, ((userid, channelid), context))

        """
        Makes the given user start listening to the given channel.
        Arguments:
        userid -- The ID of the user
        channelid -- The ID of the channel
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_startListening(self, userid, channelid, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_startListening.begin(self, ((userid, channelid), _response, _ex, _sent, context))

        """
        Makes the given user start listening to the given channel.
        Arguments:
        userid -- The ID of the user
        channelid -- The ID of the channel
        """
        def end_startListening(self, _r):
            return _M_Murmur.Server._op_startListening.end(self, _r)

        """
        Makes the given user stop listening to the given channel.
        Arguments:
        userid -- The ID of the user
        channelid -- The ID of the channel
        context -- The request context for the invocation.
        """
        def stopListening(self, userid, channelid, context=None):
            return _M_Murmur.Server._op_stopListening.invoke(self, ((userid, channelid), context))

        """
        Makes the given user stop listening to the given channel.
        Arguments:
        userid -- The ID of the user
        channelid -- The ID of the channel
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def stopListeningAsync(self, userid, channelid, context=None):
            return _M_Murmur.Server._op_stopListening.invokeAsync(self, ((userid, channelid), context))

        """
        Makes the given user stop listening to the given channel.
        Arguments:
        userid -- The ID of the user
        channelid -- The ID of the channel
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_stopListening(self, userid, channelid, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_stopListening.begin(self, ((userid, channelid), _response, _ex, _sent, context))

        """
        Makes the given user stop listening to the given channel.
        Arguments:
        userid -- The ID of the user
        channelid -- The ID of the channel
        """
        def end_stopListening(self, _r):
            return _M_Murmur.Server._op_stopListening.end(self, _r)

        """
        Arguments:
        userid -- The ID of the user
        channelid -- The ID of the channel
        context -- The request context for the invocation.
        Returns: Whether the given user is currently listening to the given channel
        """
        def isListening(self, userid, channelid, context=None):
            return _M_Murmur.Server._op_isListening.invoke(self, ((userid, channelid), context))

        """
        Arguments:
        userid -- The ID of the user
        channelid -- The ID of the channel
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def isListeningAsync(self, userid, channelid, context=None):
            return _M_Murmur.Server._op_isListening.invokeAsync(self, ((userid, channelid), context))

        """
        Arguments:
        userid -- The ID of the user
        channelid -- The ID of the channel
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_isListening(self, userid, channelid, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_isListening.begin(self, ((userid, channelid), _response, _ex, _sent, context))

        """
        Arguments:
        userid -- The ID of the user
        channelid -- The ID of the channel
        Returns: Whether the given user is currently listening to the given channel
        """
        def end_isListening(self, _r):
            return _M_Murmur.Server._op_isListening.end(self, _r)

        """
        Arguments:
        userid -- The ID of the user
        context -- The request context for the invocation.
        Returns: An ID-list of channels the given user is listening to
        """
        def getListeningChannels(self, userid, context=None):
            return _M_Murmur.Server._op_getListeningChannels.invoke(self, ((userid, ), context))

        """
        Arguments:
        userid -- The ID of the user
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getListeningChannelsAsync(self, userid, context=None):
            return _M_Murmur.Server._op_getListeningChannels.invokeAsync(self, ((userid, ), context))

        """
        Arguments:
        userid -- The ID of the user
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getListeningChannels(self, userid, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_getListeningChannels.begin(self, ((userid, ), _response, _ex, _sent, context))

        """
        Arguments:
        userid -- The ID of the user
        Returns: An ID-list of channels the given user is listening to
        """
        def end_getListeningChannels(self, _r):
            return _M_Murmur.Server._op_getListeningChannels.end(self, _r)

        """
        Arguments:
        channelid -- The ID of the channel
        context -- The request context for the invocation.
        Returns: An ID-list of users listening to the given channel
        """
        def getListeningUsers(self, channelid, context=None):
            return _M_Murmur.Server._op_getListeningUsers.invoke(self, ((channelid, ), context))

        """
        Arguments:
        channelid -- The ID of the channel
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getListeningUsersAsync(self, channelid, context=None):
            return _M_Murmur.Server._op_getListeningUsers.invokeAsync(self, ((channelid, ), context))

        """
        Arguments:
        channelid -- The ID of the channel
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getListeningUsers(self, channelid, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_getListeningUsers.begin(self, ((channelid, ), _response, _ex, _sent, context))

        """
        Arguments:
        channelid -- The ID of the channel
        Returns: An ID-list of users listening to the given channel
        """
        def end_getListeningUsers(self, _r):
            return _M_Murmur.Server._op_getListeningUsers.end(self, _r)

        """
        Arguments:
        receiverUserIDs -- list of IDs of the users the message shall be sent to
        context -- The request context for the invocation.
        """
        def sendWelcomeMessage(self, receiverUserIDs, context=None):
            return _M_Murmur.Server._op_sendWelcomeMessage.invoke(self, ((receiverUserIDs, ), context))

        """
        Arguments:
        receiverUserIDs -- list of IDs of the users the message shall be sent to
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def sendWelcomeMessageAsync(self, receiverUserIDs, context=None):
            return _M_Murmur.Server._op_sendWelcomeMessage.invokeAsync(self, ((receiverUserIDs, ), context))

        """
        Arguments:
        receiverUserIDs -- list of IDs of the users the message shall be sent to
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_sendWelcomeMessage(self, receiverUserIDs, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Server._op_sendWelcomeMessage.begin(self, ((receiverUserIDs, ), _response, _ex, _sent, context))

        def end_sendWelcomeMessage(self, _r):
            return _M_Murmur.Server._op_sendWelcomeMessage.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Murmur.ServerPrx.ice_checkedCast(proxy, '::Murmur::Server', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.ServerPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Murmur::Server'
    _M_Murmur._t_ServerPrx = IcePy.defineProxy('::Murmur::Server', ServerPrx)

    _M_Murmur.ServerPrx = ServerPrx
    del ServerPrx

    _M_Murmur.Server = Ice.createTempClass()
    class Server(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::Server')

        def ice_id(self, current=None):
            return '::Murmur::Server'

        @staticmethod
        def ice_staticId():
            return '::Murmur::Server'

        def isRunning(self, current=None):
            """
            Shows if the server currently running (accepting users).
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'isRunning' not implemented")

        def start(self, current=None):
            """
            Start server.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'start' not implemented")

        def stop(self, current=None):
            """
            Stop server.
            Note: Server will be restarted on Murmur restart unless explicitly disabled
            with setConf("boot", false)
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'stop' not implemented")

        def delete(self, current=None):
            """
            Delete server and all it's configuration.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'delete' not implemented")

        def id(self, current=None):
            """
            Fetch the server id.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'id' not implemented")

        def addCallback(self, cb, current=None):
            """
            Add a callback. The callback will receive notifications about changes to users and channels.
            Arguments:
            cb -- Callback interface which will receive notifications.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'addCallback' not implemented")

        def removeCallback(self, cb, current=None):
            """
            Remove a callback.
            Arguments:
            cb -- Callback interface to be removed.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'removeCallback' not implemented")

        def setAuthenticator(self, auth, current=None):
            """
            Set external authenticator. If set, all authentications from clients are forwarded to this
            proxy.
            Arguments:
            auth -- Authenticator object to perform subsequent authentications.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'setAuthenticator' not implemented")

        def getConf(self, key, current=None):
            """
            Retrieve configuration item.
            Arguments:
            key -- Configuration key.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getConf' not implemented")

        def getAllConf(self, current=None):
            """
            Retrieve all configuration items.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getAllConf' not implemented")

        def setConf(self, key, value, current=None):
            """
            Set a configuration item.
            Arguments:
            key -- Configuration key.
            value -- Configuration value.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'setConf' not implemented")

        def setSuperuserPassword(self, pw, current=None):
            """
            Set superuser password. This is just a convenience for using updateRegistration on user id 0.
            Arguments:
            pw -- Password.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'setSuperuserPassword' not implemented")

        def getLog(self, first, last, current=None):
            """
            Fetch log entries.
            Arguments:
            first -- Lowest numbered entry to fetch. 0 is the most recent item.
            last -- Last entry to fetch.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getLog' not implemented")

        def getLogLen(self, current=None):
            """
            Fetch length of log
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getLogLen' not implemented")

        def getUsers(self, current=None):
            """
            Fetch all users. This returns all currently connected users on the server.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getUsers' not implemented")

        def getChannels(self, current=None):
            """
            Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getChannels' not implemented")

        def getCertificateList(self, session, current=None):
            """
            Fetch certificate of user. This returns the complete certificate chain of a user.
            Arguments:
            session -- Connection ID of user. See User.session.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getCertificateList' not implemented")

        def getTree(self, current=None):
            """
            Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
            as a tree. This is primarily used for viewing the state of the server on a webpage.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getTree' not implemented")

        def getBans(self, current=None):
            """
            Fetch all current IP bans on the server.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getBans' not implemented")

        def setBans(self, bans, current=None):
            """
            Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call getBans and then
            append to the returned list before calling this method.
            Arguments:
            bans -- List of bans.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'setBans' not implemented")

        def kickUser(self, session, reason, current=None):
            """
            Kick a user. The user is not banned, and is free to rejoin the server.
            Arguments:
            session -- Connection ID of user. See User.session.
            reason -- Text message to show when user is kicked.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'kickUser' not implemented")

        def getState(self, session, current=None):
            """
            Get state of a single connected user.
            Arguments:
            session -- Connection ID of user. See User.session.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getState' not implemented")

        def setState(self, state, current=None):
            """
            Set user state. You can use this to move, mute and deafen users.
            Arguments:
            state -- User state to set.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'setState' not implemented")

        def sendMessage(self, session, text, current=None):
            """
            Send text message to a single user.
            Arguments:
            session -- Connection ID of user. See User.session.
            text -- Message to send.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'sendMessage' not implemented")

        def hasPermission(self, session, channelid, perm, current=None):
            """
            Check if user is permitted to perform action.
            Arguments:
            session -- Connection ID of user. See User.session.
            channelid -- ID of Channel. See Channel.id.
            perm -- Permission bits to check.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'hasPermission' not implemented")

        def effectivePermissions(self, session, channelid, current=None):
            """
            Return users effective permissions
            Arguments:
            session -- Connection ID of user. See User.session.
            channelid -- ID of Channel. See Channel.id.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'effectivePermissions' not implemented")

        def addContextCallback(self, session, action, text, cb, ctx, current=None):
            """
            Add a context callback. This is done per user, and will add a context menu action for the user.
            Arguments:
            session -- Session of user which should receive context entry.
            action -- Action string, a unique name to associate with the action.
            text -- Name of action shown to user.
            cb -- Callback interface which will receive notifications.
            ctx -- Context this should be used in. Needs to be one or a combination of ContextServer, ContextChannel and ContextUser.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'addContextCallback' not implemented")

        def removeContextCallback(self, cb, current=None):
            """
            Remove a callback.
            Arguments:
            cb -- Callback interface to be removed. This callback will be removed from all from all users.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'removeContextCallback' not implemented")

        def getChannelState(self, channelid, current=None):
            """
            Get state of single channel.
            Arguments:
            channelid -- ID of Channel. See Channel.id.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getChannelState' not implemented")

        def setChannelState(self, state, current=None):
            """
            Set state of a single channel. You can use this to move or relink channels.
            Arguments:
            state -- Channel state to set.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'setChannelState' not implemented")

        def removeChannel(self, channelid, current=None):
            """
            Remove a channel and all its subchannels.
            Arguments:
            channelid -- ID of Channel. See Channel.id.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'removeChannel' not implemented")

        def addChannel(self, name, parent, current=None):
            """
            Add a new channel.
            Arguments:
            name -- Name of new channel.
            parent -- Channel ID of parent channel. See Channel.id.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'addChannel' not implemented")

        def sendMessageChannel(self, channelid, tree, text, current=None):
            """
            Send text message to channel or a tree of channels.
            Arguments:
            channelid -- Channel ID of channel to send to. See Channel.id.
            tree -- If true, the message will be sent to the channel and all its subchannels.
            text -- Message to send.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'sendMessageChannel' not implemented")

        def getACL(self, channelid, current=None):
            """
            Retrieve ACLs and Groups on a channel.
            Arguments:
            channelid -- Channel ID of channel to fetch from. See Channel.id.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getACL' not implemented")

        def setACL(self, channelid, acls, groups, inherit, current=None):
            """
            Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
            Arguments:
            channelid -- Channel ID of channel to fetch from. See Channel.id.
            acls -- List of ACLs on the channel.
            groups -- List of groups on the channel.
            inherit -- Should this channel inherit ACLs from the parent channel?
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'setACL' not implemented")

        def addUserToGroup(self, channelid, session, group, current=None):
            """
            Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
            Arguments:
            channelid -- Channel ID of channel to add to. See Channel.id.
            session -- Connection ID of user. See User.session.
            group -- Group name to add to.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'addUserToGroup' not implemented")

        def removeUserFromGroup(self, channelid, session, group, current=None):
            """
            Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
            Arguments:
            channelid -- Channel ID of channel to add to. See Channel.id.
            session -- Connection ID of user. See User.session.
            group -- Group name to remove from.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'removeUserFromGroup' not implemented")

        def redirectWhisperGroup(self, session, source, target, current=None):
            """
            Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
            To remove a redirect pass an empty target string. This is intended for context groups.
            Arguments:
            session -- Connection ID of user. See User.session.
            source -- Group name to redirect from.
            target -- Group name to redirect to.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'redirectWhisperGroup' not implemented")

        def getUserNames(self, ids, current=None):
            """
            Map a list of User.userid to a matching name.
            Arguments:
            ids -- 
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getUserNames' not implemented")

        def getUserIds(self, names, current=None):
            """
            Map a list of user names to a matching id.
            @reuturn List of matching ids, with -1 representing invalid or unknown user names.
            Arguments:
            names -- 
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getUserIds' not implemented")

        def registerUser(self, info, current=None):
            """
            Register a new user.
            Arguments:
            info -- Information about new user. Must include at least "name".
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'registerUser' not implemented")

        def unregisterUser(self, userid, current=None):
            """
            Remove a user registration.
            Arguments:
            userid -- ID of registered user. See RegisteredUser.userid.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'unregisterUser' not implemented")

        def updateRegistration(self, userid, info, current=None):
            """
            Update the registration for a user. You can use this to set the email or password of a user,
            and can also use it to change the user's name.
            Arguments:
            userid -- 
            info -- 
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'updateRegistration' not implemented")

        def getRegistration(self, userid, current=None):
            """
            Fetch registration for a single user.
            Arguments:
            userid -- ID of registered user. See RegisteredUser.userid.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getRegistration' not implemented")

        def getRegisteredUsers(self, filter, current=None):
            """
            Fetch a group of registered users.
            Arguments:
            filter -- Substring of user name. If blank, will retrieve all registered users.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getRegisteredUsers' not implemented")

        def verifyPassword(self, name, pw, current=None):
            """
            Verify the password of a user. You can use this to verify a user's credentials.
            Arguments:
            name -- User name. See RegisteredUser.name.
            pw -- User password.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'verifyPassword' not implemented")

        def getTexture(self, userid, current=None):
            """
            Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
            Arguments:
            userid -- ID of registered user. See RegisteredUser.userid.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getTexture' not implemented")

        def setTexture(self, userid, tex, current=None):
            """
            Set a user texture (now called avatar).
            Arguments:
            userid -- ID of registered user. See RegisteredUser.userid.
            tex -- Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'setTexture' not implemented")

        def getUptime(self, current=None):
            """
            Get virtual server uptime.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getUptime' not implemented")

        def updateCertificate(self, certificate, privateKey, passphrase, current=None):
            """
            Update the server's certificate information.
            Reconfigure the running server's TLS socket with the given
            certificate and private key.
            The certificate and and private key must be PEM formatted.
            New clients will see the new certificate.
            Existing clients will continue to see the certificate the server
            was using when they connected to it.
            This method throws InvalidInputDataException if any of the
            following errors happen:
            - Unable to decode the PEM certificate and/or private key.
            - Unable to decrypt the private key with the given passphrase.
            - The certificate and/or private key do not contain RSA keys.
            - The certificate is not usable with the given private key.
            Arguments:
            certificate -- 
            privateKey -- 
            passphrase -- 
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'updateCertificate' not implemented")

        def startListening(self, userid, channelid, current=None):
            """
            Makes the given user start listening to the given channel.
            Arguments:
            userid -- The ID of the user
            channelid -- The ID of the channel
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'startListening' not implemented")

        def stopListening(self, userid, channelid, current=None):
            """
            Makes the given user stop listening to the given channel.
            Arguments:
            userid -- The ID of the user
            channelid -- The ID of the channel
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'stopListening' not implemented")

        def isListening(self, userid, channelid, current=None):
            """
            Arguments:
            userid -- The ID of the user
            channelid -- The ID of the channel
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'isListening' not implemented")

        def getListeningChannels(self, userid, current=None):
            """
            Arguments:
            userid -- The ID of the user
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getListeningChannels' not implemented")

        def getListeningUsers(self, channelid, current=None):
            """
            Arguments:
            channelid -- The ID of the channel
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getListeningUsers' not implemented")

        def sendWelcomeMessage(self, receiverUserIDs, current=None):
            """
            Arguments:
            receiverUserIDs -- list of IDs of the users the message shall be sent to
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'sendWelcomeMessage' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_ServerDisp)

        __repr__ = __str__

    _M_Murmur._t_ServerDisp = IcePy.defineClass('::Murmur::Server', Server, (), None, ())
    Server._ice_type = _M_Murmur._t_ServerDisp

    Server._op_isRunning = IcePy.Operation('isRunning', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), IcePy._t_bool, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Server._op_start = IcePy.Operation('start', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_ServerFailureException, _M_Murmur._t_InvalidSecretException))
    Server._op_stop = IcePy.Operation('stop', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_delete = IcePy.Operation('delete', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_id = IcePy.Operation('id', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), IcePy._t_int, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Server._op_addCallback = IcePy.Operation('addCallback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), _M_Murmur._t_ServerCallbackPrx, False, 0),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidCallbackException, _M_Murmur._t_InvalidSecretException))
    Server._op_removeCallback = IcePy.Operation('removeCallback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), _M_Murmur._t_ServerCallbackPrx, False, 0),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidCallbackException, _M_Murmur._t_InvalidSecretException))
    Server._op_setAuthenticator = IcePy.Operation('setAuthenticator', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), _M_Murmur._t_ServerAuthenticatorPrx, False, 0),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidCallbackException, _M_Murmur._t_InvalidSecretException))
    Server._op_getConf = IcePy.Operation('getConf', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_string, False, 0),), (), ((), IcePy._t_string, False, 0), (_M_Murmur._t_InvalidSecretException, _M_Murmur._t_WriteOnlyException))
    Server._op_getAllConf = IcePy.Operation('getAllConf', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), _M_Murmur._t_ConfigMap, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Server._op_setConf = IcePy.Operation('setConf', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0)), (), None, (_M_Murmur._t_InvalidSecretException,))
    Server._op_setSuperuserPassword = IcePy.Operation('setSuperuserPassword', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_string, False, 0),), (), None, (_M_Murmur._t_InvalidSecretException,))
    Server._op_getLog = IcePy.Operation('getLog', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), ((), _M_Murmur._t_LogList, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Server._op_getLogLen = IcePy.Operation('getLogLen', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), IcePy._t_int, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Server._op_getUsers = IcePy.Operation('getUsers', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), _M_Murmur._t_UserMap, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_getChannels = IcePy.Operation('getChannels', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), _M_Murmur._t_ChannelMap, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_getCertificateList = IcePy.Operation('getCertificateList', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0),), (), ((), _M_Murmur._t_CertificateList, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidSecretException))
    Server._op_getTree = IcePy.Operation('getTree', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), _M_Murmur._t_Tree, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_getBans = IcePy.Operation('getBans', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), _M_Murmur._t_BanList, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_setBans = IcePy.Operation('setBans', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), _M_Murmur._t_BanList, False, 0),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_kickUser = IcePy.Operation('kickUser', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_string, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidSecretException))
    Server._op_getState = IcePy.Operation('getState', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0),), (), ((), _M_Murmur._t_User, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidSecretException))
    Server._op_setState = IcePy.Operation('setState', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), _M_Murmur._t_User, False, 0),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSecretException))
    Server._op_sendMessage = IcePy.Operation('sendMessage', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_string, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidSecretException))
    Server._op_hasPermission = IcePy.Operation('hasPermission', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), ((), IcePy._t_bool, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSecretException))
    Server._op_effectivePermissions = IcePy.Operation('effectivePermissions', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), ((), IcePy._t_int, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSecretException))
    Server._op_addContextCallback = IcePy.Operation('addContextCallback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), _M_Murmur._t_ServerContextCallbackPrx, False, 0), ((), IcePy._t_int, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidCallbackException, _M_Murmur._t_InvalidSecretException))
    Server._op_removeContextCallback = IcePy.Operation('removeContextCallback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), _M_Murmur._t_ServerContextCallbackPrx, False, 0),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidCallbackException, _M_Murmur._t_InvalidSecretException))
    Server._op_getChannelState = IcePy.Operation('getChannelState', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0),), (), ((), _M_Murmur._t_Channel, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSecretException))
    Server._op_setChannelState = IcePy.Operation('setChannelState', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), _M_Murmur._t_Channel, False, 0),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSecretException, _M_Murmur._t_NestingLimitException))
    Server._op_removeChannel = IcePy.Operation('removeChannel', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_int, False, 0),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSecretException))
    Server._op_addChannel = IcePy.Operation('addChannel', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_string, False, 0), ((), IcePy._t_int, False, 0)), (), ((), IcePy._t_int, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSecretException, _M_Murmur._t_NestingLimitException))
    Server._op_sendMessageChannel = IcePy.Operation('sendMessageChannel', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_bool, False, 0), ((), IcePy._t_string, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSecretException))
    Server._op_getACL = IcePy.Operation('getACL', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0),), (((), _M_Murmur._t_ACLList, False, 0), ((), _M_Murmur._t_GroupList, False, 0), ((), IcePy._t_bool, False, 0)), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSecretException))
    Server._op_setACL = IcePy.Operation('setACL', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0), ((), _M_Murmur._t_ACLList, False, 0), ((), _M_Murmur._t_GroupList, False, 0), ((), IcePy._t_bool, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSecretException))
    Server._op_addUserToGroup = IcePy.Operation('addUserToGroup', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0), ((), IcePy._t_string, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidSecretException))
    Server._op_removeUserFromGroup = IcePy.Operation('removeUserFromGroup', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0), ((), IcePy._t_string, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidChannelException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidSecretException))
    Server._op_redirectWhisperGroup = IcePy.Operation('redirectWhisperGroup', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSessionException, _M_Murmur._t_InvalidSecretException))
    Server._op_getUserNames = IcePy.Operation('getUserNames', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), _M_Murmur._t_IdList, False, 0),), (), ((), _M_Murmur._t_NameMap, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_getUserIds = IcePy.Operation('getUserIds', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), _M_Murmur._t_NameList, False, 0),), (), ((), _M_Murmur._t_IdMap, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_registerUser = IcePy.Operation('registerUser', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), _M_Murmur._t_UserInfoMap, False, 0),), (), ((), IcePy._t_int, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidUserException, _M_Murmur._t_InvalidSecretException))
    Server._op_unregisterUser = IcePy.Operation('unregisterUser', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_int, False, 0),), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidUserException, _M_Murmur._t_InvalidSecretException))
    Server._op_updateRegistration = IcePy.Operation('updateRegistration', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0), ((), _M_Murmur._t_UserInfoMap, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidUserException, _M_Murmur._t_InvalidSecretException))
    Server._op_getRegistration = IcePy.Operation('getRegistration', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0),), (), ((), _M_Murmur._t_UserInfoMap, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidUserException, _M_Murmur._t_InvalidSecretException))
    Server._op_getRegisteredUsers = IcePy.Operation('getRegisteredUsers', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_string, False, 0),), (), ((), _M_Murmur._t_NameMap, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_verifyPassword = IcePy.Operation('verifyPassword', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0)), (), ((), IcePy._t_int, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_getTexture = IcePy.Operation('getTexture', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0),), (), ((), _M_Murmur._t_Texture, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidUserException, _M_Murmur._t_InvalidSecretException))
    Server._op_setTexture = IcePy.Operation('setTexture', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0), ((), _M_Murmur._t_Texture, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidUserException, _M_Murmur._t_InvalidTextureException, _M_Murmur._t_InvalidSecretException))
    Server._op_getUptime = IcePy.Operation('getUptime', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), IcePy._t_int, False, 0), (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException))
    Server._op_updateCertificate = IcePy.Operation('updateCertificate', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0)), (), None, (_M_Murmur._t_ServerBootedException, _M_Murmur._t_InvalidSecretException, _M_Murmur._t_InvalidInputDataException))
    Server._op_startListening = IcePy.Operation('startListening', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), None, ())
    Server._op_stopListening = IcePy.Operation('stopListening', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), None, ())
    Server._op_isListening = IcePy.Operation('isListening', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), ((), IcePy._t_bool, False, 0), ())
    Server._op_getListeningChannels = IcePy.Operation('getListeningChannels', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0),), (), ((), _M_Murmur._t_IntList, False, 0), ())
    Server._op_getListeningUsers = IcePy.Operation('getListeningUsers', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0),), (), ((), _M_Murmur._t_IntList, False, 0), ())
    Server._op_sendWelcomeMessage = IcePy.Operation('sendWelcomeMessage', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), _M_Murmur._t_IdList, False, 0),), (), None, ())

    _M_Murmur.Server = Server
    del Server

_M_Murmur._t_MetaCallback = IcePy.defineValue('::Murmur::MetaCallback', Ice.Value, -1, (), False, True, None, ())

if 'MetaCallbackPrx' not in _M_Murmur.__dict__:
    _M_Murmur.MetaCallbackPrx = Ice.createTempClass()
    class MetaCallbackPrx(Ice.ObjectPrx):

        """
        Called when a server is started. The server is up and running when this event is sent, so all methods that
        need a running server will work.
        Arguments:
        srv -- Interface for started server.
        context -- The request context for the invocation.
        """
        def started(self, srv, context=None):
            return _M_Murmur.MetaCallback._op_started.invoke(self, ((srv, ), context))

        """
        Called when a server is started. The server is up and running when this event is sent, so all methods that
        need a running server will work.
        Arguments:
        srv -- Interface for started server.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def startedAsync(self, srv, context=None):
            return _M_Murmur.MetaCallback._op_started.invokeAsync(self, ((srv, ), context))

        """
        Called when a server is started. The server is up and running when this event is sent, so all methods that
        need a running server will work.
        Arguments:
        srv -- Interface for started server.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_started(self, srv, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.MetaCallback._op_started.begin(self, ((srv, ), _response, _ex, _sent, context))

        """
        Called when a server is started. The server is up and running when this event is sent, so all methods that
        need a running server will work.
        Arguments:
        srv -- Interface for started server.
        """
        def end_started(self, _r):
            return _M_Murmur.MetaCallback._op_started.end(self, _r)

        """
        Called when a server is stopped. The server is already stopped when this event is sent, so no methods that
        need a running server will work.
        Arguments:
        srv -- Interface for started server.
        context -- The request context for the invocation.
        """
        def stopped(self, srv, context=None):
            return _M_Murmur.MetaCallback._op_stopped.invoke(self, ((srv, ), context))

        """
        Called when a server is stopped. The server is already stopped when this event is sent, so no methods that
        need a running server will work.
        Arguments:
        srv -- Interface for started server.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def stoppedAsync(self, srv, context=None):
            return _M_Murmur.MetaCallback._op_stopped.invokeAsync(self, ((srv, ), context))

        """
        Called when a server is stopped. The server is already stopped when this event is sent, so no methods that
        need a running server will work.
        Arguments:
        srv -- Interface for started server.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_stopped(self, srv, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.MetaCallback._op_stopped.begin(self, ((srv, ), _response, _ex, _sent, context))

        """
        Called when a server is stopped. The server is already stopped when this event is sent, so no methods that
        need a running server will work.
        Arguments:
        srv -- Interface for started server.
        """
        def end_stopped(self, _r):
            return _M_Murmur.MetaCallback._op_stopped.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Murmur.MetaCallbackPrx.ice_checkedCast(proxy, '::Murmur::MetaCallback', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.MetaCallbackPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Murmur::MetaCallback'
    _M_Murmur._t_MetaCallbackPrx = IcePy.defineProxy('::Murmur::MetaCallback', MetaCallbackPrx)

    _M_Murmur.MetaCallbackPrx = MetaCallbackPrx
    del MetaCallbackPrx

    _M_Murmur.MetaCallback = Ice.createTempClass()
    class MetaCallback(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::MetaCallback')

        def ice_id(self, current=None):
            return '::Murmur::MetaCallback'

        @staticmethod
        def ice_staticId():
            return '::Murmur::MetaCallback'

        def started(self, srv, current=None):
            """
            Called when a server is started. The server is up and running when this event is sent, so all methods that
            need a running server will work.
            Arguments:
            srv -- Interface for started server.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'started' not implemented")

        def stopped(self, srv, current=None):
            """
            Called when a server is stopped. The server is already stopped when this event is sent, so no methods that
            need a running server will work.
            Arguments:
            srv -- Interface for started server.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'stopped' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_MetaCallbackDisp)

        __repr__ = __str__

    _M_Murmur._t_MetaCallbackDisp = IcePy.defineClass('::Murmur::MetaCallback', MetaCallback, (), None, ())
    MetaCallback._ice_type = _M_Murmur._t_MetaCallbackDisp

    MetaCallback._op_started = IcePy.Operation('started', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Murmur._t_ServerPrx, False, 0),), (), None, ())
    MetaCallback._op_stopped = IcePy.Operation('stopped', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Murmur._t_ServerPrx, False, 0),), (), None, ())

    _M_Murmur.MetaCallback = MetaCallback
    del MetaCallback

if '_t_ServerList' not in _M_Murmur.__dict__:
    _M_Murmur._t_ServerList = IcePy.defineSequence('::Murmur::ServerList', (), _M_Murmur._t_ServerPrx)

_M_Murmur._t_Meta = IcePy.defineValue('::Murmur::Meta', Ice.Value, -1, (), False, True, None, ())

if 'MetaPrx' not in _M_Murmur.__dict__:
    _M_Murmur.MetaPrx = Ice.createTempClass()
    class MetaPrx(Ice.ObjectPrx):

        """
        Fetch interface to specific server.
        Arguments:
        id -- Server ID. See Server.getId.
        context -- The request context for the invocation.
        Returns: Interface for specified server, or a null proxy if id is invalid.
        """
        def getServer(self, id, context=None):
            return _M_Murmur.Meta._op_getServer.invoke(self, ((id, ), context))

        """
        Fetch interface to specific server.
        Arguments:
        id -- Server ID. See Server.getId.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getServerAsync(self, id, context=None):
            return _M_Murmur.Meta._op_getServer.invokeAsync(self, ((id, ), context))

        """
        Fetch interface to specific server.
        Arguments:
        id -- Server ID. See Server.getId.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getServer(self, id, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Meta._op_getServer.begin(self, ((id, ), _response, _ex, _sent, context))

        """
        Fetch interface to specific server.
        Arguments:
        id -- Server ID. See Server.getId.
        Returns: Interface for specified server, or a null proxy if id is invalid.
        """
        def end_getServer(self, _r):
            return _M_Murmur.Meta._op_getServer.end(self, _r)

        """
        Create a new server. Call Server.getId on the returned interface to find it's ID.
        Arguments:
        context -- The request context for the invocation.
        Returns: Interface for new server.
        """
        def newServer(self, context=None):
            return _M_Murmur.Meta._op_newServer.invoke(self, ((), context))

        """
        Create a new server. Call Server.getId on the returned interface to find it's ID.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def newServerAsync(self, context=None):
            return _M_Murmur.Meta._op_newServer.invokeAsync(self, ((), context))

        """
        Create a new server. Call Server.getId on the returned interface to find it's ID.
        Arguments:
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_newServer(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Meta._op_newServer.begin(self, ((), _response, _ex, _sent, context))

        """
        Create a new server. Call Server.getId on the returned interface to find it's ID.
        Arguments:
        Returns: Interface for new server.
        """
        def end_newServer(self, _r):
            return _M_Murmur.Meta._op_newServer.end(self, _r)

        """
        Fetch list of all currently running servers.
        Arguments:
        context -- The request context for the invocation.
        Returns: List of interfaces for running servers.
        """
        def getBootedServers(self, context=None):
            return _M_Murmur.Meta._op_getBootedServers.invoke(self, ((), context))

        """
        Fetch list of all currently running servers.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getBootedServersAsync(self, context=None):
            return _M_Murmur.Meta._op_getBootedServers.invokeAsync(self, ((), context))

        """
        Fetch list of all currently running servers.
        Arguments:
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getBootedServers(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Meta._op_getBootedServers.begin(self, ((), _response, _ex, _sent, context))

        """
        Fetch list of all currently running servers.
        Arguments:
        Returns: List of interfaces for running servers.
        """
        def end_getBootedServers(self, _r):
            return _M_Murmur.Meta._op_getBootedServers.end(self, _r)

        """
        Fetch list of all defined servers.
        Arguments:
        context -- The request context for the invocation.
        Returns: List of interfaces for all servers.
        """
        def getAllServers(self, context=None):
            return _M_Murmur.Meta._op_getAllServers.invoke(self, ((), context))

        """
        Fetch list of all defined servers.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getAllServersAsync(self, context=None):
            return _M_Murmur.Meta._op_getAllServers.invokeAsync(self, ((), context))

        """
        Fetch list of all defined servers.
        Arguments:
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getAllServers(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Meta._op_getAllServers.begin(self, ((), _response, _ex, _sent, context))

        """
        Fetch list of all defined servers.
        Arguments:
        Returns: List of interfaces for all servers.
        """
        def end_getAllServers(self, _r):
            return _M_Murmur.Meta._op_getAllServers.end(self, _r)

        """
        Fetch default configuration. This returns the configuration items that were set in the configuration file, or
        the built-in default. The individual servers will use these values unless they have been overridden in the
        server specific configuration. The only special case is the port, which defaults to the value defined here +
        the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
        Arguments:
        context -- The request context for the invocation.
        Returns: Default configuration of the servers.
        """
        def getDefaultConf(self, context=None):
            return _M_Murmur.Meta._op_getDefaultConf.invoke(self, ((), context))

        """
        Fetch default configuration. This returns the configuration items that were set in the configuration file, or
        the built-in default. The individual servers will use these values unless they have been overridden in the
        server specific configuration. The only special case is the port, which defaults to the value defined here +
        the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getDefaultConfAsync(self, context=None):
            return _M_Murmur.Meta._op_getDefaultConf.invokeAsync(self, ((), context))

        """
        Fetch default configuration. This returns the configuration items that were set in the configuration file, or
        the built-in default. The individual servers will use these values unless they have been overridden in the
        server specific configuration. The only special case is the port, which defaults to the value defined here +
        the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
        Arguments:
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getDefaultConf(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Meta._op_getDefaultConf.begin(self, ((), _response, _ex, _sent, context))

        """
        Fetch default configuration. This returns the configuration items that were set in the configuration file, or
        the built-in default. The individual servers will use these values unless they have been overridden in the
        server specific configuration. The only special case is the port, which defaults to the value defined here +
        the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
        Arguments:
        Returns: Default configuration of the servers.
        """
        def end_getDefaultConf(self, _r):
            return _M_Murmur.Meta._op_getDefaultConf.end(self, _r)

        """
        Fetch version of Murmur.
        Arguments:
        context -- The request context for the invocation.
        Returns a tuple containing the following:
        major -- Major version.
        minor -- Minor version.
        patch -- Patchlevel.
        text -- Textual representation of version. Note that this may not match the major, minor and patch levels, as it may be simply the compile date or the SVN revision. This is usually the text you want to present to users.
        """
        def getVersion(self, context=None):
            return _M_Murmur.Meta._op_getVersion.invoke(self, ((), context))

        """
        Fetch version of Murmur.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getVersionAsync(self, context=None):
            return _M_Murmur.Meta._op_getVersion.invokeAsync(self, ((), context))

        """
        Fetch version of Murmur.
        Arguments:
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getVersion(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Meta._op_getVersion.begin(self, ((), _response, _ex, _sent, context))

        """
        Fetch version of Murmur.
        Arguments:
        Returns a tuple containing the following:
        major -- Major version.
        minor -- Minor version.
        patch -- Patchlevel.
        text -- Textual representation of version. Note that this may not match the major, minor and patch levels, as it may be simply the compile date or the SVN revision. This is usually the text you want to present to users.
        """
        def end_getVersion(self, _r):
            return _M_Murmur.Meta._op_getVersion.end(self, _r)

        """
        Add a callback. The callback will receive notifications when servers are started or stopped.
        Arguments:
        cb -- Callback interface which will receive notifications.
        context -- The request context for the invocation.
        """
        def addCallback(self, cb, context=None):
            return _M_Murmur.Meta._op_addCallback.invoke(self, ((cb, ), context))

        """
        Add a callback. The callback will receive notifications when servers are started or stopped.
        Arguments:
        cb -- Callback interface which will receive notifications.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def addCallbackAsync(self, cb, context=None):
            return _M_Murmur.Meta._op_addCallback.invokeAsync(self, ((cb, ), context))

        """
        Add a callback. The callback will receive notifications when servers are started or stopped.
        Arguments:
        cb -- Callback interface which will receive notifications.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_addCallback(self, cb, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Meta._op_addCallback.begin(self, ((cb, ), _response, _ex, _sent, context))

        """
        Add a callback. The callback will receive notifications when servers are started or stopped.
        Arguments:
        cb -- Callback interface which will receive notifications.
        """
        def end_addCallback(self, _r):
            return _M_Murmur.Meta._op_addCallback.end(self, _r)

        """
        Remove a callback.
        Arguments:
        cb -- Callback interface to be removed.
        context -- The request context for the invocation.
        """
        def removeCallback(self, cb, context=None):
            return _M_Murmur.Meta._op_removeCallback.invoke(self, ((cb, ), context))

        """
        Remove a callback.
        Arguments:
        cb -- Callback interface to be removed.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def removeCallbackAsync(self, cb, context=None):
            return _M_Murmur.Meta._op_removeCallback.invokeAsync(self, ((cb, ), context))

        """
        Remove a callback.
        Arguments:
        cb -- Callback interface to be removed.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_removeCallback(self, cb, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Meta._op_removeCallback.begin(self, ((cb, ), _response, _ex, _sent, context))

        """
        Remove a callback.
        Arguments:
        cb -- Callback interface to be removed.
        """
        def end_removeCallback(self, _r):
            return _M_Murmur.Meta._op_removeCallback.end(self, _r)

        """
        Get murmur uptime.
        Arguments:
        context -- The request context for the invocation.
        Returns: Uptime of murmur in seconds
        """
        def getUptime(self, context=None):
            return _M_Murmur.Meta._op_getUptime.invoke(self, ((), context))

        """
        Get murmur uptime.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getUptimeAsync(self, context=None):
            return _M_Murmur.Meta._op_getUptime.invokeAsync(self, ((), context))

        """
        Get murmur uptime.
        Arguments:
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getUptime(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Meta._op_getUptime.begin(self, ((), _response, _ex, _sent, context))

        """
        Get murmur uptime.
        Arguments:
        Returns: Uptime of murmur in seconds
        """
        def end_getUptime(self, _r):
            return _M_Murmur.Meta._op_getUptime.end(self, _r)

        """
        Get slice file.
        Arguments:
        context -- The request context for the invocation.
        Returns: Contents of the slice file server compiled with.
        """
        def getSlice(self, context=None):
            return _M_Murmur.Meta._op_getSlice.invoke(self, ((), context))

        """
        Get slice file.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getSliceAsync(self, context=None):
            return _M_Murmur.Meta._op_getSlice.invokeAsync(self, ((), context))

        """
        Get slice file.
        Arguments:
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getSlice(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Meta._op_getSlice.begin(self, ((), _response, _ex, _sent, context))

        """
        Get slice file.
        Arguments:
        Returns: Contents of the slice file server compiled with.
        """
        def end_getSlice(self, _r):
            return _M_Murmur.Meta._op_getSlice.end(self, _r)

        """
        Returns a checksum dict for the slice file.
        Arguments:
        context -- The request context for the invocation.
        Returns: Checksum dict
        """
        def getSliceChecksums(self, context=None):
            return _M_Murmur.Meta._op_getSliceChecksums.invoke(self, ((), context))

        """
        Returns a checksum dict for the slice file.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getSliceChecksumsAsync(self, context=None):
            return _M_Murmur.Meta._op_getSliceChecksums.invokeAsync(self, ((), context))

        """
        Returns a checksum dict for the slice file.
        Arguments:
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getSliceChecksums(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Murmur.Meta._op_getSliceChecksums.begin(self, ((), _response, _ex, _sent, context))

        """
        Returns a checksum dict for the slice file.
        Arguments:
        Returns: Checksum dict
        """
        def end_getSliceChecksums(self, _r):
            return _M_Murmur.Meta._op_getSliceChecksums.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Murmur.MetaPrx.ice_checkedCast(proxy, '::Murmur::Meta', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Murmur.MetaPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Murmur::Meta'
    _M_Murmur._t_MetaPrx = IcePy.defineProxy('::Murmur::Meta', MetaPrx)

    _M_Murmur.MetaPrx = MetaPrx
    del MetaPrx

    _M_Murmur.Meta = Ice.createTempClass()
    class Meta(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Murmur::Meta')

        def ice_id(self, current=None):
            return '::Murmur::Meta'

        @staticmethod
        def ice_staticId():
            return '::Murmur::Meta'

        def getServer(self, id, current=None):
            """
            Fetch interface to specific server.
            Arguments:
            id -- Server ID. See Server.getId.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getServer' not implemented")

        def newServer(self, current=None):
            """
            Create a new server. Call Server.getId on the returned interface to find it's ID.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'newServer' not implemented")

        def getBootedServers(self, current=None):
            """
            Fetch list of all currently running servers.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getBootedServers' not implemented")

        def getAllServers(self, current=None):
            """
            Fetch list of all defined servers.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getAllServers' not implemented")

        def getDefaultConf(self, current=None):
            """
            Fetch default configuration. This returns the configuration items that were set in the configuration file, or
            the built-in default. The individual servers will use these values unless they have been overridden in the
            server specific configuration. The only special case is the port, which defaults to the value defined here +
            the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getDefaultConf' not implemented")

        def getVersion(self, current=None):
            """
            Fetch version of Murmur.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getVersion' not implemented")

        def addCallback(self, cb, current=None):
            """
            Add a callback. The callback will receive notifications when servers are started or stopped.
            Arguments:
            cb -- Callback interface which will receive notifications.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'addCallback' not implemented")

        def removeCallback(self, cb, current=None):
            """
            Remove a callback.
            Arguments:
            cb -- Callback interface to be removed.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'removeCallback' not implemented")

        def getUptime(self, current=None):
            """
            Get murmur uptime.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getUptime' not implemented")

        def getSlice(self, current=None):
            """
            Get slice file.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getSlice' not implemented")

        def getSliceChecksums(self, current=None):
            """
            Returns a checksum dict for the slice file.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getSliceChecksums' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Murmur._t_MetaDisp)

        __repr__ = __str__

    _M_Murmur._t_MetaDisp = IcePy.defineClass('::Murmur::Meta', Meta, (), None, ())
    Meta._ice_type = _M_Murmur._t_MetaDisp

    Meta._op_getServer = IcePy.Operation('getServer', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (((), IcePy._t_int, False, 0),), (), ((), _M_Murmur._t_ServerPrx, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Meta._op_newServer = IcePy.Operation('newServer', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (), (), ((), _M_Murmur._t_ServerPrx, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Meta._op_getBootedServers = IcePy.Operation('getBootedServers', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), _M_Murmur._t_ServerList, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Meta._op_getAllServers = IcePy.Operation('getAllServers', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), _M_Murmur._t_ServerList, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Meta._op_getDefaultConf = IcePy.Operation('getDefaultConf', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), _M_Murmur._t_ConfigMap, False, 0), (_M_Murmur._t_InvalidSecretException,))
    Meta._op_getVersion = IcePy.Operation('getVersion', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0), ((), IcePy._t_string, False, 0)), None, ())
    Meta._op_addCallback = IcePy.Operation('addCallback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), _M_Murmur._t_MetaCallbackPrx, False, 0),), (), None, (_M_Murmur._t_InvalidCallbackException, _M_Murmur._t_InvalidSecretException))
    Meta._op_removeCallback = IcePy.Operation('removeCallback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), _M_Murmur._t_MetaCallbackPrx, False, 0),), (), None, (_M_Murmur._t_InvalidCallbackException, _M_Murmur._t_InvalidSecretException))
    Meta._op_getUptime = IcePy.Operation('getUptime', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), IcePy._t_int, False, 0), ())
    Meta._op_getSlice = IcePy.Operation('getSlice', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), IcePy._t_string, False, 0), ())
    Meta._op_getSliceChecksums = IcePy.Operation('getSliceChecksums', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, True, None, (), (), (), ((), _M_Ice._t_SliceChecksumDict, False, 0), ())

    _M_Murmur.Meta = Meta
    del Meta

# End of module Murmur

Ice.sliceChecksums["::Murmur::ACL"] = "157797fb27cda83faec7e5374284e275"
Ice.sliceChecksums["::Murmur::ACLList"] = "c0d51a6dadd205ea4ceed3ab8605e"
Ice.sliceChecksums["::Murmur::Ban"] = "77c83f17e3b1603f5d35b47fa33870"
Ice.sliceChecksums["::Murmur::BanList"] = "0c7df186822caffee1c2391a82de0a8"
Ice.sliceChecksums["::Murmur::CertificateDer"] = "bda5350e8ec40eef1cae7c2b3c616cf"
Ice.sliceChecksums["::Murmur::CertificateList"] = "bb8d3e415f174d82a74a3abebeadc0"
Ice.sliceChecksums["::Murmur::Channel"] = "3d7546228b98475e03e4bd2eef7042"
Ice.sliceChecksums["::Murmur::ChannelInfo"] = "1e1c915adb3475dd6aa6943aff139d7c"
Ice.sliceChecksums["::Murmur::ChannelList"] = "b6a00a1063ca328741442333853ac"
Ice.sliceChecksums["::Murmur::ChannelMap"] = "c680d84f229348aeac44fceda7a02cc8"
Ice.sliceChecksums["::Murmur::ConfigMap"] = "a959102c70f61ff099b044a145ba2a"
Ice.sliceChecksums["::Murmur::ContextChannel"] = "d031ddb65dbaea316b6718ffa867852"
Ice.sliceChecksums["::Murmur::ContextServer"] = "36637f606caa3dfe7a88816f3d1d4b4"
Ice.sliceChecksums["::Murmur::ContextUser"] = "928e6ca841dc5467d671cc7e94a47b1"
Ice.sliceChecksums["::Murmur::Group"] = "351a3b2b4d272047beca8770793874b"
Ice.sliceChecksums["::Murmur::GroupList"] = "cbca3d925b7b06eb1d0ca15379977e8"
Ice.sliceChecksums["::Murmur::GroupNameList"] = "3129349326861d482a77548514a44ea9"
Ice.sliceChecksums["::Murmur::IdList"] = "ee9f8c35179c12487ff62e359b7f267b"
Ice.sliceChecksums["::Murmur::IdMap"] = "36f07840567acf5a1a182b80cc4ec4c8"
Ice.sliceChecksums["::Murmur::IntList"] = "6f1c32278d7993b8e7fcab62838cfa6"
Ice.sliceChecksums["::Murmur::InvalidCallbackException"] = "8f793feff89155d9b9b47cd11c283f"
Ice.sliceChecksums["::Murmur::InvalidChannelException"] = "551df6f38d8243dfc01b8ae610f0a41b"
Ice.sliceChecksums["::Murmur::InvalidInputDataException"] = "f28c685e6e2ccaa11687822d24d80ba"
Ice.sliceChecksums["::Murmur::InvalidSecretException"] = "2fb9069906614c74d6f54ffb7299723"
Ice.sliceChecksums["::Murmur::InvalidServerException"] = "8c23808992774379fd0deede158a24d"
Ice.sliceChecksums["::Murmur::InvalidSessionException"] = "411551c2f6abb9aa68b0dce4da1f2261"
Ice.sliceChecksums["::Murmur::InvalidTextureException"] = "c2f0fb931df3ceac9f3b231d90d1f66a"
Ice.sliceChecksums["::Murmur::InvalidUserException"] = "deaaf2325132ceebde9ba71eae8aae0"
Ice.sliceChecksums["::Murmur::LogEntry"] = "baf7375450f0cf5a4221ac1080297efb"
Ice.sliceChecksums["::Murmur::LogList"] = "816cdfe716397174d44069acd3309836"
Ice.sliceChecksums["::Murmur::Meta"] = "11f0c26da8d8ffb8135a7028ddfe43e"
Ice.sliceChecksums["::Murmur::MetaCallback"] = "8769511071e0b08b8dfc4b1ca1c352a"
Ice.sliceChecksums["::Murmur::MurmurException"] = "f14e757fac3ec91e3eb581beaf8d1af"
Ice.sliceChecksums["::Murmur::NameList"] = "492b93e2b12d2bd7f61f719a67b8623b"
Ice.sliceChecksums["::Murmur::NameMap"] = "8eb7985198a0add716b9462cbdd8c"
Ice.sliceChecksums["::Murmur::NestingLimitException"] = "f7a9a488daca3d97d689debc832c76"
Ice.sliceChecksums["::Murmur::NetAddress"] = "fe2a565d478baf1e5e2168ca4492d9d"
Ice.sliceChecksums["::Murmur::PermissionBan"] = "ac198d670d743c882937073eae3247"
Ice.sliceChecksums["::Murmur::PermissionEnter"] = "54fa28c949285c187f4df657b087b8"
Ice.sliceChecksums["::Murmur::PermissionKick"] = "15a8e0bcd0862dba4b5b72550f09aad"
Ice.sliceChecksums["::Murmur::PermissionLinkChannel"] = "992d2978f5eb8c5c5c8ec68aee4f890"
Ice.sliceChecksums["::Murmur::PermissionMakeChannel"] = "7cb412acce465d84c9a11bc5cd43e66"
Ice.sliceChecksums["::Murmur::PermissionMakeTempChannel"] = "beeec37912c744f855149ab30608344"
Ice.sliceChecksums["::Murmur::PermissionMove"] = "19f25e8a3ccabbbdf7316a675d6cc87"
Ice.sliceChecksums["::Murmur::PermissionMuteDeafen"] = "53c56b4bd8cf231a4090ef24ed893939"
Ice.sliceChecksums["::Murmur::PermissionRegister"] = "d0c4e13de6abc868b79cf01bb7d5c1ad"
Ice.sliceChecksums["::Murmur::PermissionRegisterSelf"] = "3a9718827e1cdc13b1fde4a724df8"
Ice.sliceChecksums["::Murmur::PermissionSpeak"] = "cfd814f27bac13db9c9a342a0512a4b"
Ice.sliceChecksums["::Murmur::PermissionTextMessage"] = "b5d36eeecdffc56a3a72854a1469145b"
Ice.sliceChecksums["::Murmur::PermissionTraverse"] = "37f12b9bb96c0d07a7c45e1bfef0fe"
Ice.sliceChecksums["::Murmur::PermissionWhisper"] = "dddf47c35e992f8cd868c4321f9bcb"
Ice.sliceChecksums["::Murmur::PermissionWrite"] = "a939b87d29f9fff8b2f957b3e4b121c0"
Ice.sliceChecksums["::Murmur::ResetUserContent"] = "144ba8653415acdee3d3f946a18058"
Ice.sliceChecksums["::Murmur::Server"] = "6ae1cdc268e435bab7cbab20a5697acb"
Ice.sliceChecksums["::Murmur::ServerAuthenticator"] = "53d631793acaba02db8a24971d9032"
Ice.sliceChecksums["::Murmur::ServerBootedException"] = "ddeb7c96e12425ac5fa5a6a94f956"
Ice.sliceChecksums["::Murmur::ServerCallback"] = "8963c15b917c6dac6ab1a7abdbd"
Ice.sliceChecksums["::Murmur::ServerContextCallback"] = "aa3c7926b1cea864d4a280e116ce42"
Ice.sliceChecksums["::Murmur::ServerFailureException"] = "1fe7854e87d2f446c8ff19f38043e821"
Ice.sliceChecksums["::Murmur::ServerList"] = "c4b0f170133f5681b162f8eff53fe"
Ice.sliceChecksums["::Murmur::ServerUpdatingAuthenticator"] = "ad94f3cb11cd39bf69ad81f879af45f"
Ice.sliceChecksums["::Murmur::TextMessage"] = "31d8456b13daf9ab43832a7b381f73b7"
Ice.sliceChecksums["::Murmur::Texture"] = "141dd3bb5aa45668e290153de4e8a23c"
Ice.sliceChecksums["::Murmur::Tree"] = "d22bc269c9dab07c1ff38be14e4bf89"
Ice.sliceChecksums["::Murmur::TreeList"] = "d7942bdad7624ea9e13a297b75fa7da"
Ice.sliceChecksums["::Murmur::User"] = "b0d23475ce2fc5fd59558ea55796946"
Ice.sliceChecksums["::Murmur::UserInfo"] = "3c1a3c8ac61325a80f23f21e5466294"
Ice.sliceChecksums["::Murmur::UserInfoMap"] = "422b99b6357d73912dfea65a794c41a6"
Ice.sliceChecksums["::Murmur::UserList"] = "629ef93051c372dd4ab85895fd9d311"
Ice.sliceChecksums["::Murmur::UserMap"] = "787e8028481a284f43687305c91473"
Ice.sliceChecksums["::Murmur::WriteOnlyException"] = "8aca8bfe9c995581fe3dc942c5a342b"
